Checking use_after_free.c ...
use_after_free.c:56:14: style: Condition 'user!=NULL' is always false [knownConditionTrueFalse]
    if (user != NULL) {
             ^
use_after_free.c:53:12: note: Assignment 'user=NULL', assigned value is 0
    user = NULL;
           ^
use_after_free.c:56:14: note: Condition 'user!=NULL' is always false
    if (user != NULL) {
             ^
use_after_free.c:33:5: error: Memory pointed to by 'user' is freed twice. [doubleFree]
    free(user);
    ^
use_after_free.c:26:5: note: Memory pointed to by 'user' is freed twice.
    free(user);
    ^
use_after_free.c:33:5: note: Memory pointed to by 'user' is freed twice.
    free(user);
    ^
use_after_free.c:20:5: warning: If memory allocation fails, then there is a possible null pointer dereference: user [nullPointerOutOfMemory]
    user->id = 1;
    ^
use_after_free.c:18:31: note: Assuming allocation function fails
    User *user = (User*)malloc(sizeof(User));
                              ^
use_after_free.c:18:18: note: Assignment 'user=(struct User*)malloc(sizeof(struct User))', assigned value is 0
    User *user = (User*)malloc(sizeof(User));
                 ^
use_after_free.c:20:5: note: Null pointer dereference
    user->id = 1;
    ^
use_after_free.c:21:12: warning: If memory allocation fails, then there is a possible null pointer dereference: user [nullPointerOutOfMemory]
    strcpy(user->name, "John Doe");
           ^
use_after_free.c:18:31: note: Assuming allocation function fails
    User *user = (User*)malloc(sizeof(User));
                              ^
use_after_free.c:18:18: note: Assignment 'user=(struct User*)malloc(sizeof(struct User))', assigned value is 0
    User *user = (User*)malloc(sizeof(User));
                 ^
use_after_free.c:21:12: note: Null pointer dereference
    strcpy(user->name, "John Doe");
           ^
use_after_free.c:23:39: warning: If memory allocation fails, then there is a possible null pointer dereference: user [nullPointerOutOfMemory]
    printf("User ID: %d, Name: %s\n", user->id, user->name);
                                      ^
use_after_free.c:18:31: note: Assuming allocation function fails
    User *user = (User*)malloc(sizeof(User));
                              ^
use_after_free.c:18:18: note: Assignment 'user=(struct User*)malloc(sizeof(struct User))', assigned value is 0
    User *user = (User*)malloc(sizeof(User));
                 ^
use_after_free.c:23:39: note: Null pointer dereference
    printf("User ID: %d, Name: %s\n", user->id, user->name);
                                      ^
use_after_free.c:17:0: style: The function 'vulnerable_use_after_free' is never used. [unusedFunction]
void vulnerable_use_after_free() {
^
use_after_free.c:36:0: style: The function 'correct_usage' should have static linkage since it is not used outside of its translation unit. [staticFunction]
void correct_usage() {
^
nofile:0:0: information: Active checkers: 109/856 (use --checkers-report=<filename> to see details) [checkersReport]

