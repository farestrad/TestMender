{
  "version": "1.141.0",
  "results": [
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_01.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 1998
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2034
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_01.c",
      "start": {
        "line": 161,
        "col": 13,
        "offset": 4551
      },
      "end": {
        "line": 161,
        "col": 49,
        "offset": 4587
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_02.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2121
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2157
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_02.c",
      "start": {
        "line": 154,
        "col": 17,
        "offset": 4569
      },
      "end": {
        "line": 154,
        "col": 53,
        "offset": 4605
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_02.c",
      "start": {
        "line": 239,
        "col": 17,
        "offset": 7268
      },
      "end": {
        "line": 239,
        "col": 53,
        "offset": 7304
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_03.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2130
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2166
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_03.c",
      "start": {
        "line": 154,
        "col": 17,
        "offset": 4590
      },
      "end": {
        "line": 154,
        "col": 53,
        "offset": 4626
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_03.c",
      "start": {
        "line": 239,
        "col": 17,
        "offset": 7295
      },
      "end": {
        "line": 239,
        "col": 53,
        "offset": 7331
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_04.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2441
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2477
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_04.c",
      "start": {
        "line": 160,
        "col": 17,
        "offset": 4954
      },
      "end": {
        "line": 160,
        "col": 53,
        "offset": 4990
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_04.c",
      "start": {
        "line": 245,
        "col": 17,
        "offset": 7686
      },
      "end": {
        "line": 245,
        "col": 53,
        "offset": 7722
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_05.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2440
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2476
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_05.c",
      "start": {
        "line": 160,
        "col": 17,
        "offset": 4925
      },
      "end": {
        "line": 160,
        "col": 53,
        "offset": 4961
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_05.c",
      "start": {
        "line": 245,
        "col": 17,
        "offset": 7643
      },
      "end": {
        "line": 245,
        "col": 53,
        "offset": 7679
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_06.c",
      "start": {
        "line": 80,
        "col": 17,
        "offset": 2372
      },
      "end": {
        "line": 80,
        "col": 53,
        "offset": 2408
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_06.c",
      "start": {
        "line": 159,
        "col": 17,
        "offset": 4896
      },
      "end": {
        "line": 159,
        "col": 53,
        "offset": 4932
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_06.c",
      "start": {
        "line": 244,
        "col": 17,
        "offset": 7633
      },
      "end": {
        "line": 244,
        "col": 53,
        "offset": 7669
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_07.c",
      "start": {
        "line": 80,
        "col": 17,
        "offset": 2380
      },
      "end": {
        "line": 80,
        "col": 53,
        "offset": 2416
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_07.c",
      "start": {
        "line": 159,
        "col": 17,
        "offset": 4876
      },
      "end": {
        "line": 159,
        "col": 53,
        "offset": 4912
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_07.c",
      "start": {
        "line": 244,
        "col": 17,
        "offset": 7599
      },
      "end": {
        "line": 244,
        "col": 53,
        "offset": 7635
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_08.c",
      "start": {
        "line": 88,
        "col": 17,
        "offset": 2454
      },
      "end": {
        "line": 88,
        "col": 53,
        "offset": 2490
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_08.c",
      "start": {
        "line": 167,
        "col": 17,
        "offset": 4975
      },
      "end": {
        "line": 167,
        "col": 53,
        "offset": 5011
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_08.c",
      "start": {
        "line": 252,
        "col": 17,
        "offset": 7711
      },
      "end": {
        "line": 252,
        "col": 53,
        "offset": 7747
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_09.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2170
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2206
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_09.c",
      "start": {
        "line": 154,
        "col": 17,
        "offset": 4683
      },
      "end": {
        "line": 154,
        "col": 53,
        "offset": 4719
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_09.c",
      "start": {
        "line": 239,
        "col": 17,
        "offset": 7415
      },
      "end": {
        "line": 239,
        "col": 53,
        "offset": 7451
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_10.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2149
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2185
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_10.c",
      "start": {
        "line": 154,
        "col": 17,
        "offset": 4634
      },
      "end": {
        "line": 154,
        "col": 53,
        "offset": 4670
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_10.c",
      "start": {
        "line": 239,
        "col": 17,
        "offset": 7352
      },
      "end": {
        "line": 239,
        "col": 53,
        "offset": 7388
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_11.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2176
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2212
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_11.c",
      "start": {
        "line": 154,
        "col": 17,
        "offset": 4697
      },
      "end": {
        "line": 154,
        "col": 53,
        "offset": 4733
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_11.c",
      "start": {
        "line": 239,
        "col": 17,
        "offset": 7433
      },
      "end": {
        "line": 239,
        "col": 53,
        "offset": 7469
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_12.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2161
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2197
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_12.c",
      "start": {
        "line": 174,
        "col": 17,
        "offset": 5238
      },
      "end": {
        "line": 174,
        "col": 53,
        "offset": 5274
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_12.c",
      "start": {
        "line": 233,
        "col": 17,
        "offset": 7281
      },
      "end": {
        "line": 233,
        "col": 53,
        "offset": 7317
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_13.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2178
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2214
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_13.c",
      "start": {
        "line": 154,
        "col": 17,
        "offset": 4702
      },
      "end": {
        "line": 154,
        "col": 53,
        "offset": 4738
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_13.c",
      "start": {
        "line": 239,
        "col": 17,
        "offset": 7439
      },
      "end": {
        "line": 239,
        "col": 53,
        "offset": 7475
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_14.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2157
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2193
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_14.c",
      "start": {
        "line": 154,
        "col": 17,
        "offset": 4653
      },
      "end": {
        "line": 154,
        "col": 53,
        "offset": 4689
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_14.c",
      "start": {
        "line": 239,
        "col": 17,
        "offset": 7376
      },
      "end": {
        "line": 239,
        "col": 53,
        "offset": 7412
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_15.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2062
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2098
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_15.c",
      "start": {
        "line": 167,
        "col": 13,
        "offset": 4661
      },
      "end": {
        "line": 167,
        "col": 49,
        "offset": 4697
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_15.c",
      "start": {
        "line": 259,
        "col": 13,
        "offset": 7382
      },
      "end": {
        "line": 259,
        "col": 49,
        "offset": 7418
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_16.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2117
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2153
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_16.c",
      "start": {
        "line": 156,
        "col": 17,
        "offset": 4623
      },
      "end": {
        "line": 156,
        "col": 53,
        "offset": 4659
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_17.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2146
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2182
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_17.c",
      "start": {
        "line": 156,
        "col": 17,
        "offset": 4632
      },
      "end": {
        "line": 156,
        "col": 53,
        "offset": 4668
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_18.c",
      "start": {
        "line": 75,
        "col": 13,
        "offset": 2046
      },
      "end": {
        "line": 75,
        "col": 49,
        "offset": 2082
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_18.c",
      "start": {
        "line": 152,
        "col": 13,
        "offset": 4295
      },
      "end": {
        "line": 152,
        "col": 49,
        "offset": 4331
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_21.c",
      "start": {
        "line": 88,
        "col": 13,
        "offset": 2448
      },
      "end": {
        "line": 88,
        "col": 49,
        "offset": 2484
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_21.c",
      "start": {
        "line": 185,
        "col": 13,
        "offset": 5274
      },
      "end": {
        "line": 185,
        "col": 49,
        "offset": 5310
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_21.c",
      "start": {
        "line": 268,
        "col": 13,
        "offset": 7737
      },
      "end": {
        "line": 268,
        "col": 49,
        "offset": 7773
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_22a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2339
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2375
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_22a.c",
      "start": {
        "line": 155,
        "col": 13,
        "offset": 4947
      },
      "end": {
        "line": 155,
        "col": 49,
        "offset": 4983
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_22a.c",
      "start": {
        "line": 223,
        "col": 13,
        "offset": 7204
      },
      "end": {
        "line": 223,
        "col": 49,
        "offset": 7240
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_31.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 2045
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2081
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_31.c",
      "start": {
        "line": 169,
        "col": 13,
        "offset": 4790
      },
      "end": {
        "line": 169,
        "col": 49,
        "offset": 4826
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_32.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2239
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2275
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_32.c",
      "start": {
        "line": 183,
        "col": 17,
        "offset": 5390
      },
      "end": {
        "line": 183,
        "col": 53,
        "offset": 5426
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_34.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2295
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2331
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_34.c",
      "start": {
        "line": 178,
        "col": 13,
        "offset": 5216
      },
      "end": {
        "line": 178,
        "col": 49,
        "offset": 5252
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_41.c",
      "start": {
        "line": 82,
        "col": 13,
        "offset": 2268
      },
      "end": {
        "line": 82,
        "col": 49,
        "offset": 2304
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_41.c",
      "start": {
        "line": 185,
        "col": 13,
        "offset": 5071
      },
      "end": {
        "line": 185,
        "col": 49,
        "offset": 5107
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_42.c",
      "start": {
        "line": 70,
        "col": 13,
        "offset": 1979
      },
      "end": {
        "line": 70,
        "col": 49,
        "offset": 2015
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_42.c",
      "start": {
        "line": 170,
        "col": 13,
        "offset": 4758
      },
      "end": {
        "line": 170,
        "col": 49,
        "offset": 4794
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_44.c",
      "start": {
        "line": 84,
        "col": 13,
        "offset": 2384
      },
      "end": {
        "line": 84,
        "col": 49,
        "offset": 2420
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_44.c",
      "start": {
        "line": 190,
        "col": 13,
        "offset": 5307
      },
      "end": {
        "line": 190,
        "col": 49,
        "offset": 5343
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_45.c",
      "start": {
        "line": 87,
        "col": 13,
        "offset": 2575
      },
      "end": {
        "line": 87,
        "col": 49,
        "offset": 2611
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_45.c",
      "start": {
        "line": 194,
        "col": 13,
        "offset": 5666
      },
      "end": {
        "line": 194,
        "col": 49,
        "offset": 5702
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_51a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2195
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2231
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_51a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4764
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4800
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_52a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2212
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2248
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_52a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4781
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4817
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_53a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2239
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2275
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_53a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4808
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4844
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_54a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2240
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2276
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_54a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4809
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4845
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_61b.c",
      "start": {
        "line": 70,
        "col": 13,
        "offset": 2028
      },
      "end": {
        "line": 70,
        "col": 49,
        "offset": 2064
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_61b.c",
      "start": {
        "line": 144,
        "col": 13,
        "offset": 4325
      },
      "end": {
        "line": 144,
        "col": 49,
        "offset": 4361
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_63a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2196
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2232
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_63a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4771
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4807
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_64a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2206
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2242
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_64a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4797
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4833
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_65a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2364
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2400
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_65a.c",
      "start": {
        "line": 165,
        "col": 13,
        "offset": 5049
      },
      "end": {
        "line": 165,
        "col": 49,
        "offset": 5085
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_66a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2222
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2258
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_66a.c",
      "start": {
        "line": 166,
        "col": 13,
        "offset": 4942
      },
      "end": {
        "line": 166,
        "col": 49,
        "offset": 4978
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_67a.c",
      "start": {
        "line": 82,
        "col": 13,
        "offset": 2503
      },
      "end": {
        "line": 82,
        "col": 49,
        "offset": 2539
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_67a.c",
      "start": {
        "line": 170,
        "col": 13,
        "offset": 5426
      },
      "end": {
        "line": 170,
        "col": 49,
        "offset": 5462
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_68a.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2398
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2434
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_68a.c",
      "start": {
        "line": 166,
        "col": 13,
        "offset": 5123
      },
      "end": {
        "line": 166,
        "col": 49,
        "offset": 5159
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_01.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 2039
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2075
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_01.c",
      "start": {
        "line": 163,
        "col": 13,
        "offset": 4710
      },
      "end": {
        "line": 163,
        "col": 49,
        "offset": 4746
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_02.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2162
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2198
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_02.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4673
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4709
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_02.c",
      "start": {
        "line": 243,
        "col": 17,
        "offset": 7500
      },
      "end": {
        "line": 243,
        "col": 53,
        "offset": 7536
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_03.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2171
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2207
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_03.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4694
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4730
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_03.c",
      "start": {
        "line": 243,
        "col": 17,
        "offset": 7527
      },
      "end": {
        "line": 243,
        "col": 53,
        "offset": 7563
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_04.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2482
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2518
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_04.c",
      "start": {
        "line": 161,
        "col": 17,
        "offset": 5058
      },
      "end": {
        "line": 161,
        "col": 53,
        "offset": 5094
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_04.c",
      "start": {
        "line": 249,
        "col": 17,
        "offset": 7918
      },
      "end": {
        "line": 249,
        "col": 53,
        "offset": 7954
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_05.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2481
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2517
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_05.c",
      "start": {
        "line": 161,
        "col": 17,
        "offset": 5029
      },
      "end": {
        "line": 161,
        "col": 53,
        "offset": 5065
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_05.c",
      "start": {
        "line": 249,
        "col": 17,
        "offset": 7875
      },
      "end": {
        "line": 249,
        "col": 53,
        "offset": 7911
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_06.c",
      "start": {
        "line": 80,
        "col": 17,
        "offset": 2413
      },
      "end": {
        "line": 80,
        "col": 53,
        "offset": 2449
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_06.c",
      "start": {
        "line": 160,
        "col": 17,
        "offset": 5000
      },
      "end": {
        "line": 160,
        "col": 53,
        "offset": 5036
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_06.c",
      "start": {
        "line": 248,
        "col": 17,
        "offset": 7865
      },
      "end": {
        "line": 248,
        "col": 53,
        "offset": 7901
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_07.c",
      "start": {
        "line": 80,
        "col": 17,
        "offset": 2421
      },
      "end": {
        "line": 80,
        "col": 53,
        "offset": 2457
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_07.c",
      "start": {
        "line": 160,
        "col": 17,
        "offset": 4980
      },
      "end": {
        "line": 160,
        "col": 53,
        "offset": 5016
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_07.c",
      "start": {
        "line": 248,
        "col": 17,
        "offset": 7831
      },
      "end": {
        "line": 248,
        "col": 53,
        "offset": 7867
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_08.c",
      "start": {
        "line": 88,
        "col": 17,
        "offset": 2495
      },
      "end": {
        "line": 88,
        "col": 53,
        "offset": 2531
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_08.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 5079
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 5115
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_08.c",
      "start": {
        "line": 256,
        "col": 17,
        "offset": 7943
      },
      "end": {
        "line": 256,
        "col": 53,
        "offset": 7979
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_09.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2211
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2247
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_09.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4787
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4823
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_09.c",
      "start": {
        "line": 243,
        "col": 17,
        "offset": 7647
      },
      "end": {
        "line": 243,
        "col": 53,
        "offset": 7683
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_10.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2190
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2226
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_10.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4738
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4774
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_10.c",
      "start": {
        "line": 243,
        "col": 17,
        "offset": 7584
      },
      "end": {
        "line": 243,
        "col": 53,
        "offset": 7620
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_11.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2217
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2253
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_11.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4801
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4837
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_11.c",
      "start": {
        "line": 243,
        "col": 17,
        "offset": 7665
      },
      "end": {
        "line": 243,
        "col": 53,
        "offset": 7701
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_12.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2202
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2238
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_12.c",
      "start": {
        "line": 178,
        "col": 17,
        "offset": 5470
      },
      "end": {
        "line": 178,
        "col": 53,
        "offset": 5506
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_12.c",
      "start": {
        "line": 237,
        "col": 17,
        "offset": 7513
      },
      "end": {
        "line": 237,
        "col": 53,
        "offset": 7549
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_13.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2219
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2255
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_13.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4806
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4842
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_13.c",
      "start": {
        "line": 243,
        "col": 17,
        "offset": 7671
      },
      "end": {
        "line": 243,
        "col": 53,
        "offset": 7707
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_14.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2198
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2234
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_14.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4757
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4793
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_14.c",
      "start": {
        "line": 243,
        "col": 17,
        "offset": 7608
      },
      "end": {
        "line": 243,
        "col": 53,
        "offset": 7644
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_15.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2103
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2139
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_15.c",
      "start": {
        "line": 168,
        "col": 13,
        "offset": 4789
      },
      "end": {
        "line": 168,
        "col": 49,
        "offset": 4825
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_15.c",
      "start": {
        "line": 263,
        "col": 13,
        "offset": 7638
      },
      "end": {
        "line": 263,
        "col": 49,
        "offset": 7674
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_16.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2158
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2194
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_16.c",
      "start": {
        "line": 157,
        "col": 17,
        "offset": 4727
      },
      "end": {
        "line": 157,
        "col": 53,
        "offset": 4763
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_17.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2187
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2223
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_17.c",
      "start": {
        "line": 157,
        "col": 17,
        "offset": 4736
      },
      "end": {
        "line": 157,
        "col": 53,
        "offset": 4772
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_18.c",
      "start": {
        "line": 75,
        "col": 13,
        "offset": 2087
      },
      "end": {
        "line": 75,
        "col": 49,
        "offset": 2123
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_18.c",
      "start": {
        "line": 153,
        "col": 13,
        "offset": 4395
      },
      "end": {
        "line": 153,
        "col": 49,
        "offset": 4431
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_21.c",
      "start": {
        "line": 89,
        "col": 13,
        "offset": 2552
      },
      "end": {
        "line": 89,
        "col": 49,
        "offset": 2588
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_21.c",
      "start": {
        "line": 189,
        "col": 13,
        "offset": 5506
      },
      "end": {
        "line": 189,
        "col": 49,
        "offset": 5542
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_21.c",
      "start": {
        "line": 275,
        "col": 13,
        "offset": 8097
      },
      "end": {
        "line": 275,
        "col": 49,
        "offset": 8133
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_22a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2390
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2426
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_22a.c",
      "start": {
        "line": 155,
        "col": 13,
        "offset": 5028
      },
      "end": {
        "line": 155,
        "col": 49,
        "offset": 5064
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_22a.c",
      "start": {
        "line": 223,
        "col": 13,
        "offset": 7300
      },
      "end": {
        "line": 223,
        "col": 49,
        "offset": 7336
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_31.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 2086
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2122
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_31.c",
      "start": {
        "line": 171,
        "col": 13,
        "offset": 4957
      },
      "end": {
        "line": 171,
        "col": 49,
        "offset": 4993
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_32.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2280
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2316
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_32.c",
      "start": {
        "line": 185,
        "col": 17,
        "offset": 5557
      },
      "end": {
        "line": 185,
        "col": 53,
        "offset": 5593
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_34.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2346
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2382
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_34.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5403
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5439
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_41.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2368
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2404
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_41.c",
      "start": {
        "line": 190,
        "col": 13,
        "offset": 5346
      },
      "end": {
        "line": 190,
        "col": 49,
        "offset": 5382
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_42.c",
      "start": {
        "line": 70,
        "col": 13,
        "offset": 2015
      },
      "end": {
        "line": 70,
        "col": 49,
        "offset": 2051
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_42.c",
      "start": {
        "line": 172,
        "col": 13,
        "offset": 4917
      },
      "end": {
        "line": 172,
        "col": 49,
        "offset": 4953
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_44.c",
      "start": {
        "line": 85,
        "col": 13,
        "offset": 2484
      },
      "end": {
        "line": 85,
        "col": 49,
        "offset": 2520
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_44.c",
      "start": {
        "line": 195,
        "col": 13,
        "offset": 5582
      },
      "end": {
        "line": 195,
        "col": 49,
        "offset": 5618
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_45.c",
      "start": {
        "line": 88,
        "col": 13,
        "offset": 2695
      },
      "end": {
        "line": 88,
        "col": 49,
        "offset": 2731
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_45.c",
      "start": {
        "line": 199,
        "col": 13,
        "offset": 5981
      },
      "end": {
        "line": 199,
        "col": 49,
        "offset": 6017
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_51a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2241
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2277
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_51a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4830
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4866
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_52a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2258
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2294
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_52a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4847
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4883
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_53a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2285
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2321
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_53a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4874
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4910
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_54a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2286
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2322
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_54a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4875
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4911
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_61b.c",
      "start": {
        "line": 70,
        "col": 13,
        "offset": 2069
      },
      "end": {
        "line": 70,
        "col": 49,
        "offset": 2105
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_61b.c",
      "start": {
        "line": 144,
        "col": 13,
        "offset": 4376
      },
      "end": {
        "line": 144,
        "col": 49,
        "offset": 4412
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_63a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2242
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2278
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_63a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4837
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4873
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_64a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2252
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2288
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_64a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4863
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4899
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_65a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2415
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2451
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_65a.c",
      "start": {
        "line": 165,
        "col": 13,
        "offset": 5120
      },
      "end": {
        "line": 165,
        "col": 49,
        "offset": 5156
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_66a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2268
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2304
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_66a.c",
      "start": {
        "line": 166,
        "col": 13,
        "offset": 5008
      },
      "end": {
        "line": 166,
        "col": 49,
        "offset": 5044
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_67a.c",
      "start": {
        "line": 82,
        "col": 13,
        "offset": 2569
      },
      "end": {
        "line": 82,
        "col": 49,
        "offset": 2605
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_67a.c",
      "start": {
        "line": 170,
        "col": 13,
        "offset": 5532
      },
      "end": {
        "line": 170,
        "col": 49,
        "offset": 5568
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_68a.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2459
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2495
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_68a.c",
      "start": {
        "line": 166,
        "col": 13,
        "offset": 5214
      },
      "end": {
        "line": 166,
        "col": 49,
        "offset": 5250
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_01.c",
      "start": {
        "line": 75,
        "col": 13,
        "offset": 2022
      },
      "end": {
        "line": 75,
        "col": 49,
        "offset": 2058
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_01.c",
      "start": {
        "line": 163,
        "col": 13,
        "offset": 4589
      },
      "end": {
        "line": 163,
        "col": 49,
        "offset": 4625
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_02.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2145
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2181
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_02.c",
      "start": {
        "line": 156,
        "col": 17,
        "offset": 4600
      },
      "end": {
        "line": 156,
        "col": 53,
        "offset": 4636
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_02.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7345
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7381
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_03.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2154
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2190
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_03.c",
      "start": {
        "line": 156,
        "col": 17,
        "offset": 4621
      },
      "end": {
        "line": 156,
        "col": 53,
        "offset": 4657
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_03.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7372
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7408
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_04.c",
      "start": {
        "line": 83,
        "col": 17,
        "offset": 2465
      },
      "end": {
        "line": 83,
        "col": 53,
        "offset": 2501
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_04.c",
      "start": {
        "line": 162,
        "col": 17,
        "offset": 4985
      },
      "end": {
        "line": 162,
        "col": 53,
        "offset": 5021
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_04.c",
      "start": {
        "line": 247,
        "col": 17,
        "offset": 7763
      },
      "end": {
        "line": 247,
        "col": 53,
        "offset": 7799
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_05.c",
      "start": {
        "line": 83,
        "col": 17,
        "offset": 2464
      },
      "end": {
        "line": 83,
        "col": 53,
        "offset": 2500
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_05.c",
      "start": {
        "line": 162,
        "col": 17,
        "offset": 4956
      },
      "end": {
        "line": 162,
        "col": 53,
        "offset": 4992
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_05.c",
      "start": {
        "line": 247,
        "col": 17,
        "offset": 7720
      },
      "end": {
        "line": 247,
        "col": 53,
        "offset": 7756
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_06.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2396
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2432
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_06.c",
      "start": {
        "line": 161,
        "col": 17,
        "offset": 4927
      },
      "end": {
        "line": 161,
        "col": 53,
        "offset": 4963
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_06.c",
      "start": {
        "line": 246,
        "col": 17,
        "offset": 7710
      },
      "end": {
        "line": 246,
        "col": 53,
        "offset": 7746
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_07.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2404
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2440
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_07.c",
      "start": {
        "line": 161,
        "col": 17,
        "offset": 4907
      },
      "end": {
        "line": 161,
        "col": 53,
        "offset": 4943
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_07.c",
      "start": {
        "line": 246,
        "col": 17,
        "offset": 7676
      },
      "end": {
        "line": 246,
        "col": 53,
        "offset": 7712
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_08.c",
      "start": {
        "line": 90,
        "col": 17,
        "offset": 2478
      },
      "end": {
        "line": 90,
        "col": 53,
        "offset": 2514
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_08.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5006
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5042
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_08.c",
      "start": {
        "line": 254,
        "col": 17,
        "offset": 7788
      },
      "end": {
        "line": 254,
        "col": 53,
        "offset": 7824
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_09.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2194
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2230
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_09.c",
      "start": {
        "line": 156,
        "col": 17,
        "offset": 4714
      },
      "end": {
        "line": 156,
        "col": 53,
        "offset": 4750
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_09.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7492
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7528
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_10.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2173
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2209
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_10.c",
      "start": {
        "line": 156,
        "col": 17,
        "offset": 4665
      },
      "end": {
        "line": 156,
        "col": 53,
        "offset": 4701
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_10.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7429
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7465
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_11.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2200
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2236
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_11.c",
      "start": {
        "line": 156,
        "col": 17,
        "offset": 4728
      },
      "end": {
        "line": 156,
        "col": 53,
        "offset": 4764
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_11.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7510
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7546
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_12.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2185
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2221
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_12.c",
      "start": {
        "line": 176,
        "col": 17,
        "offset": 5315
      },
      "end": {
        "line": 176,
        "col": 53,
        "offset": 5351
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_12.c",
      "start": {
        "line": 235,
        "col": 17,
        "offset": 7358
      },
      "end": {
        "line": 235,
        "col": 53,
        "offset": 7394
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_13.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2202
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2238
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_13.c",
      "start": {
        "line": 156,
        "col": 17,
        "offset": 4733
      },
      "end": {
        "line": 156,
        "col": 53,
        "offset": 4769
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_13.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7516
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7552
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_14.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2181
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2217
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_14.c",
      "start": {
        "line": 156,
        "col": 17,
        "offset": 4684
      },
      "end": {
        "line": 156,
        "col": 53,
        "offset": 4720
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_14.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7453
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7489
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_15.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2086
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2122
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_15.c",
      "start": {
        "line": 169,
        "col": 13,
        "offset": 4692
      },
      "end": {
        "line": 169,
        "col": 49,
        "offset": 4728
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_15.c",
      "start": {
        "line": 261,
        "col": 13,
        "offset": 7459
      },
      "end": {
        "line": 261,
        "col": 49,
        "offset": 7495
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_16.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2141
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2177
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_16.c",
      "start": {
        "line": 158,
        "col": 17,
        "offset": 4654
      },
      "end": {
        "line": 158,
        "col": 53,
        "offset": 4690
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_17.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2170
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2206
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_17.c",
      "start": {
        "line": 158,
        "col": 17,
        "offset": 4663
      },
      "end": {
        "line": 158,
        "col": 53,
        "offset": 4699
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_18.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2070
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2106
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_18.c",
      "start": {
        "line": 154,
        "col": 13,
        "offset": 4326
      },
      "end": {
        "line": 154,
        "col": 49,
        "offset": 4362
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_21.c",
      "start": {
        "line": 90,
        "col": 13,
        "offset": 2479
      },
      "end": {
        "line": 90,
        "col": 49,
        "offset": 2515
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_21.c",
      "start": {
        "line": 187,
        "col": 13,
        "offset": 5351
      },
      "end": {
        "line": 187,
        "col": 49,
        "offset": 5387
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_21.c",
      "start": {
        "line": 270,
        "col": 13,
        "offset": 7860
      },
      "end": {
        "line": 270,
        "col": 49,
        "offset": 7896
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_22a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2348
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2384
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_22a.c",
      "start": {
        "line": 155,
        "col": 13,
        "offset": 4974
      },
      "end": {
        "line": 155,
        "col": 49,
        "offset": 5010
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_22a.c",
      "start": {
        "line": 223,
        "col": 13,
        "offset": 7240
      },
      "end": {
        "line": 223,
        "col": 49,
        "offset": 7276
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_31.c",
      "start": {
        "line": 75,
        "col": 13,
        "offset": 2069
      },
      "end": {
        "line": 75,
        "col": 49,
        "offset": 2105
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_31.c",
      "start": {
        "line": 171,
        "col": 13,
        "offset": 4828
      },
      "end": {
        "line": 171,
        "col": 49,
        "offset": 4864
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_32.c",
      "start": {
        "line": 79,
        "col": 17,
        "offset": 2263
      },
      "end": {
        "line": 79,
        "col": 53,
        "offset": 2299
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_32.c",
      "start": {
        "line": 185,
        "col": 17,
        "offset": 5428
      },
      "end": {
        "line": 185,
        "col": 53,
        "offset": 5464
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_34.c",
      "start": {
        "line": 82,
        "col": 13,
        "offset": 2325
      },
      "end": {
        "line": 82,
        "col": 49,
        "offset": 2361
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_34.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5266
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5302
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_41.c",
      "start": {
        "line": 84,
        "col": 13,
        "offset": 2299
      },
      "end": {
        "line": 84,
        "col": 49,
        "offset": 2335
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_41.c",
      "start": {
        "line": 187,
        "col": 13,
        "offset": 5155
      },
      "end": {
        "line": 187,
        "col": 49,
        "offset": 5191
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_42.c",
      "start": {
        "line": 72,
        "col": 13,
        "offset": 2000
      },
      "end": {
        "line": 72,
        "col": 49,
        "offset": 2036
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_42.c",
      "start": {
        "line": 172,
        "col": 13,
        "offset": 4796
      },
      "end": {
        "line": 172,
        "col": 49,
        "offset": 4832
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_44.c",
      "start": {
        "line": 86,
        "col": 13,
        "offset": 2415
      },
      "end": {
        "line": 86,
        "col": 49,
        "offset": 2451
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_44.c",
      "start": {
        "line": 192,
        "col": 13,
        "offset": 5391
      },
      "end": {
        "line": 192,
        "col": 49,
        "offset": 5427
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_45.c",
      "start": {
        "line": 89,
        "col": 13,
        "offset": 2618
      },
      "end": {
        "line": 89,
        "col": 49,
        "offset": 2654
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_45.c",
      "start": {
        "line": 196,
        "col": 13,
        "offset": 5774
      },
      "end": {
        "line": 196,
        "col": 49,
        "offset": 5810
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_51a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2222
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2258
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_51a.c",
      "start": {
        "line": 162,
        "col": 13,
        "offset": 4803
      },
      "end": {
        "line": 162,
        "col": 49,
        "offset": 4839
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_52a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2239
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2275
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_52a.c",
      "start": {
        "line": 162,
        "col": 13,
        "offset": 4820
      },
      "end": {
        "line": 162,
        "col": 49,
        "offset": 4856
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_53a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2266
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2302
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_53a.c",
      "start": {
        "line": 162,
        "col": 13,
        "offset": 4847
      },
      "end": {
        "line": 162,
        "col": 49,
        "offset": 4883
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_54a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2267
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2303
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_54a.c",
      "start": {
        "line": 162,
        "col": 13,
        "offset": 4848
      },
      "end": {
        "line": 162,
        "col": 49,
        "offset": 4884
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_61b.c",
      "start": {
        "line": 72,
        "col": 13,
        "offset": 2052
      },
      "end": {
        "line": 72,
        "col": 49,
        "offset": 2088
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_61b.c",
      "start": {
        "line": 146,
        "col": 13,
        "offset": 4355
      },
      "end": {
        "line": 146,
        "col": 49,
        "offset": 4391
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_63a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2223
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2259
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_63a.c",
      "start": {
        "line": 162,
        "col": 13,
        "offset": 4810
      },
      "end": {
        "line": 162,
        "col": 49,
        "offset": 4846
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_64a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2233
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2269
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_64a.c",
      "start": {
        "line": 162,
        "col": 13,
        "offset": 4836
      },
      "end": {
        "line": 162,
        "col": 49,
        "offset": 4872
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_65a.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2394
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2430
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_65a.c",
      "start": {
        "line": 167,
        "col": 13,
        "offset": 5091
      },
      "end": {
        "line": 167,
        "col": 49,
        "offset": 5127
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_66a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2249
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2285
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_66a.c",
      "start": {
        "line": 168,
        "col": 13,
        "offset": 4981
      },
      "end": {
        "line": 168,
        "col": 49,
        "offset": 5017
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_67a.c",
      "start": {
        "line": 84,
        "col": 13,
        "offset": 2542
      },
      "end": {
        "line": 84,
        "col": 49,
        "offset": 2578
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_67a.c",
      "start": {
        "line": 172,
        "col": 13,
        "offset": 5489
      },
      "end": {
        "line": 172,
        "col": 49,
        "offset": 5525
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_68a.c",
      "start": {
        "line": 82,
        "col": 13,
        "offset": 2434
      },
      "end": {
        "line": 82,
        "col": 49,
        "offset": 2470
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_68a.c",
      "start": {
        "line": 168,
        "col": 13,
        "offset": 5177
      },
      "end": {
        "line": 168,
        "col": 49,
        "offset": 5213
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_01.c",
      "start": {
        "line": 74,
        "col": 13,
        "offset": 2014
      },
      "end": {
        "line": 74,
        "col": 49,
        "offset": 2050
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_01.c",
      "start": {
        "line": 175,
        "col": 13,
        "offset": 4883
      },
      "end": {
        "line": 175,
        "col": 49,
        "offset": 4919
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_02.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2141
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2177
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_02.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 4957
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 4993
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_02.c",
      "start": {
        "line": 266,
        "col": 17,
        "offset": 8024
      },
      "end": {
        "line": 266,
        "col": 53,
        "offset": 8060
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_03.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2150
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2186
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_03.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 4978
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 5014
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_03.c",
      "start": {
        "line": 266,
        "col": 17,
        "offset": 8051
      },
      "end": {
        "line": 266,
        "col": 53,
        "offset": 8087
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_04.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2461
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2497
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_04.c",
      "start": {
        "line": 174,
        "col": 17,
        "offset": 5342
      },
      "end": {
        "line": 174,
        "col": 53,
        "offset": 5378
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_04.c",
      "start": {
        "line": 272,
        "col": 17,
        "offset": 8442
      },
      "end": {
        "line": 272,
        "col": 53,
        "offset": 8478
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_05.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2460
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2496
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_05.c",
      "start": {
        "line": 174,
        "col": 17,
        "offset": 5313
      },
      "end": {
        "line": 174,
        "col": 53,
        "offset": 5349
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_05.c",
      "start": {
        "line": 272,
        "col": 17,
        "offset": 8399
      },
      "end": {
        "line": 272,
        "col": 53,
        "offset": 8435
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_06.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2392
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2428
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_06.c",
      "start": {
        "line": 173,
        "col": 17,
        "offset": 5284
      },
      "end": {
        "line": 173,
        "col": 53,
        "offset": 5320
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_06.c",
      "start": {
        "line": 271,
        "col": 17,
        "offset": 8389
      },
      "end": {
        "line": 271,
        "col": 53,
        "offset": 8425
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_07.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2400
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2436
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_07.c",
      "start": {
        "line": 173,
        "col": 17,
        "offset": 5264
      },
      "end": {
        "line": 173,
        "col": 53,
        "offset": 5300
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_07.c",
      "start": {
        "line": 271,
        "col": 17,
        "offset": 8355
      },
      "end": {
        "line": 271,
        "col": 53,
        "offset": 8391
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_08.c",
      "start": {
        "line": 89,
        "col": 17,
        "offset": 2474
      },
      "end": {
        "line": 89,
        "col": 53,
        "offset": 2510
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_08.c",
      "start": {
        "line": 181,
        "col": 17,
        "offset": 5363
      },
      "end": {
        "line": 181,
        "col": 53,
        "offset": 5399
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_08.c",
      "start": {
        "line": 279,
        "col": 17,
        "offset": 8467
      },
      "end": {
        "line": 279,
        "col": 53,
        "offset": 8503
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_09.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2190
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2226
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_09.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 5071
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 5107
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_09.c",
      "start": {
        "line": 266,
        "col": 17,
        "offset": 8171
      },
      "end": {
        "line": 266,
        "col": 53,
        "offset": 8207
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_10.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2169
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2205
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_10.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 5022
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 5058
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_10.c",
      "start": {
        "line": 266,
        "col": 17,
        "offset": 8108
      },
      "end": {
        "line": 266,
        "col": 53,
        "offset": 8144
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_11.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2196
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2232
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_11.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 5085
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 5121
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_11.c",
      "start": {
        "line": 266,
        "col": 17,
        "offset": 8189
      },
      "end": {
        "line": 266,
        "col": 53,
        "offset": 8225
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_12.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2181
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2217
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_12.c",
      "start": {
        "line": 188,
        "col": 17,
        "offset": 5626
      },
      "end": {
        "line": 188,
        "col": 53,
        "offset": 5662
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_12.c",
      "start": {
        "line": 260,
        "col": 17,
        "offset": 8037
      },
      "end": {
        "line": 260,
        "col": 53,
        "offset": 8073
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_13.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2198
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2234
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_13.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 5090
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 5126
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_13.c",
      "start": {
        "line": 266,
        "col": 17,
        "offset": 8195
      },
      "end": {
        "line": 266,
        "col": 53,
        "offset": 8231
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_14.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2177
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2213
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_14.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 5041
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 5077
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_14.c",
      "start": {
        "line": 266,
        "col": 17,
        "offset": 8132
      },
      "end": {
        "line": 266,
        "col": 53,
        "offset": 8168
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_15.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2078
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2114
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_15.c",
      "start": {
        "line": 181,
        "col": 13,
        "offset": 4993
      },
      "end": {
        "line": 181,
        "col": 49,
        "offset": 5029
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_15.c",
      "start": {
        "line": 286,
        "col": 13,
        "offset": 8030
      },
      "end": {
        "line": 286,
        "col": 49,
        "offset": 8066
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_16.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2137
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2173
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_16.c",
      "start": {
        "line": 170,
        "col": 17,
        "offset": 5011
      },
      "end": {
        "line": 170,
        "col": 53,
        "offset": 5047
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_17.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2166
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2202
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_17.c",
      "start": {
        "line": 170,
        "col": 17,
        "offset": 5020
      },
      "end": {
        "line": 170,
        "col": 53,
        "offset": 5056
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_18.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2062
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2098
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_18.c",
      "start": {
        "line": 166,
        "col": 13,
        "offset": 4627
      },
      "end": {
        "line": 166,
        "col": 49,
        "offset": 4663
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_21.c",
      "start": {
        "line": 89,
        "col": 13,
        "offset": 2464
      },
      "end": {
        "line": 89,
        "col": 49,
        "offset": 2500
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_21.c",
      "start": {
        "line": 199,
        "col": 13,
        "offset": 5606
      },
      "end": {
        "line": 199,
        "col": 49,
        "offset": 5642
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_21.c",
      "start": {
        "line": 295,
        "col": 13,
        "offset": 8385
      },
      "end": {
        "line": 295,
        "col": 49,
        "offset": 8421
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_22a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2353
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2389
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_22a.c",
      "start": {
        "line": 169,
        "col": 13,
        "offset": 5271
      },
      "end": {
        "line": 169,
        "col": 49,
        "offset": 5307
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_22a.c",
      "start": {
        "line": 250,
        "col": 13,
        "offset": 7841
      },
      "end": {
        "line": 250,
        "col": 49,
        "offset": 7877
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_31.c",
      "start": {
        "line": 74,
        "col": 13,
        "offset": 2061
      },
      "end": {
        "line": 74,
        "col": 49,
        "offset": 2097
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_31.c",
      "start": {
        "line": 183,
        "col": 13,
        "offset": 5122
      },
      "end": {
        "line": 183,
        "col": 49,
        "offset": 5158
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_32.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2259
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2295
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_32.c",
      "start": {
        "line": 197,
        "col": 17,
        "offset": 5778
      },
      "end": {
        "line": 197,
        "col": 53,
        "offset": 5814
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_34.c",
      "start": {
        "line": 81,
        "col": 13,
        "offset": 2309
      },
      "end": {
        "line": 81,
        "col": 49,
        "offset": 2345
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_34.c",
      "start": {
        "line": 192,
        "col": 13,
        "offset": 5544
      },
      "end": {
        "line": 192,
        "col": 49,
        "offset": 5580
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_41.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2284
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2320
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_41.c",
      "start": {
        "line": 199,
        "col": 13,
        "offset": 5403
      },
      "end": {
        "line": 199,
        "col": 49,
        "offset": 5439
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_42.c",
      "start": {
        "line": 71,
        "col": 13,
        "offset": 1996
      },
      "end": {
        "line": 71,
        "col": 49,
        "offset": 2032
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_42.c",
      "start": {
        "line": 184,
        "col": 13,
        "offset": 5090
      },
      "end": {
        "line": 184,
        "col": 49,
        "offset": 5126
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_44.c",
      "start": {
        "line": 85,
        "col": 13,
        "offset": 2400
      },
      "end": {
        "line": 85,
        "col": 49,
        "offset": 2436
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_44.c",
      "start": {
        "line": 204,
        "col": 13,
        "offset": 5639
      },
      "end": {
        "line": 204,
        "col": 49,
        "offset": 5675
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_45.c",
      "start": {
        "line": 88,
        "col": 13,
        "offset": 2587
      },
      "end": {
        "line": 88,
        "col": 49,
        "offset": 2623
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_45.c",
      "start": {
        "line": 208,
        "col": 13,
        "offset": 5990
      },
      "end": {
        "line": 208,
        "col": 49,
        "offset": 6026
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_51a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2210
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2246
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_51a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5091
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5127
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_52a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2227
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2263
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_52a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5108
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5144
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_53a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2254
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2290
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_53a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5135
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5171
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_54a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2255
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2291
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_54a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5136
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5172
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_61b.c",
      "start": {
        "line": 71,
        "col": 13,
        "offset": 2044
      },
      "end": {
        "line": 71,
        "col": 49,
        "offset": 2080
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_61b.c",
      "start": {
        "line": 158,
        "col": 13,
        "offset": 4655
      },
      "end": {
        "line": 158,
        "col": 49,
        "offset": 4691
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_63a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2211
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2247
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_63a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5098
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5134
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_64a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2221
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2257
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_64a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5124
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5160
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_65a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2378
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2414
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_65a.c",
      "start": {
        "line": 179,
        "col": 13,
        "offset": 5375
      },
      "end": {
        "line": 179,
        "col": 49,
        "offset": 5411
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_66a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2237
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2273
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_66a.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5269
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5305
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_67a.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2514
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2550
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_67a.c",
      "start": {
        "line": 184,
        "col": 13,
        "offset": 5745
      },
      "end": {
        "line": 184,
        "col": 49,
        "offset": 5781
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_68a.c",
      "start": {
        "line": 81,
        "col": 13,
        "offset": 2410
      },
      "end": {
        "line": 81,
        "col": 49,
        "offset": 2446
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_68a.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5445
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5481
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_01.c",
      "start": {
        "line": 74,
        "col": 13,
        "offset": 2055
      },
      "end": {
        "line": 74,
        "col": 49,
        "offset": 2091
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_01.c",
      "start": {
        "line": 177,
        "col": 13,
        "offset": 5042
      },
      "end": {
        "line": 177,
        "col": 49,
        "offset": 5078
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_02.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2182
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2218
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_02.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5061
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5097
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_02.c",
      "start": {
        "line": 270,
        "col": 17,
        "offset": 8256
      },
      "end": {
        "line": 270,
        "col": 53,
        "offset": 8292
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_03.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2191
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2227
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_03.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5082
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5118
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_03.c",
      "start": {
        "line": 270,
        "col": 17,
        "offset": 8283
      },
      "end": {
        "line": 270,
        "col": 53,
        "offset": 8319
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_04.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2502
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2538
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_04.c",
      "start": {
        "line": 175,
        "col": 17,
        "offset": 5446
      },
      "end": {
        "line": 175,
        "col": 53,
        "offset": 5482
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_04.c",
      "start": {
        "line": 276,
        "col": 17,
        "offset": 8674
      },
      "end": {
        "line": 276,
        "col": 53,
        "offset": 8710
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_05.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2501
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2537
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_05.c",
      "start": {
        "line": 175,
        "col": 17,
        "offset": 5417
      },
      "end": {
        "line": 175,
        "col": 53,
        "offset": 5453
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_05.c",
      "start": {
        "line": 276,
        "col": 17,
        "offset": 8631
      },
      "end": {
        "line": 276,
        "col": 53,
        "offset": 8667
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_06.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2433
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2469
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_06.c",
      "start": {
        "line": 174,
        "col": 17,
        "offset": 5388
      },
      "end": {
        "line": 174,
        "col": 53,
        "offset": 5424
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_06.c",
      "start": {
        "line": 275,
        "col": 17,
        "offset": 8621
      },
      "end": {
        "line": 275,
        "col": 53,
        "offset": 8657
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_07.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2441
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2477
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_07.c",
      "start": {
        "line": 174,
        "col": 17,
        "offset": 5368
      },
      "end": {
        "line": 174,
        "col": 53,
        "offset": 5404
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_07.c",
      "start": {
        "line": 275,
        "col": 17,
        "offset": 8587
      },
      "end": {
        "line": 275,
        "col": 53,
        "offset": 8623
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_08.c",
      "start": {
        "line": 89,
        "col": 17,
        "offset": 2515
      },
      "end": {
        "line": 89,
        "col": 53,
        "offset": 2551
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_08.c",
      "start": {
        "line": 182,
        "col": 17,
        "offset": 5467
      },
      "end": {
        "line": 182,
        "col": 53,
        "offset": 5503
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_08.c",
      "start": {
        "line": 283,
        "col": 17,
        "offset": 8699
      },
      "end": {
        "line": 283,
        "col": 53,
        "offset": 8735
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_09.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2231
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2267
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_09.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5175
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5211
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_09.c",
      "start": {
        "line": 270,
        "col": 17,
        "offset": 8403
      },
      "end": {
        "line": 270,
        "col": 53,
        "offset": 8439
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_10.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2210
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2246
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_10.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5126
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5162
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_10.c",
      "start": {
        "line": 270,
        "col": 17,
        "offset": 8340
      },
      "end": {
        "line": 270,
        "col": 53,
        "offset": 8376
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_11.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2237
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2273
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_11.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5189
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5225
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_11.c",
      "start": {
        "line": 270,
        "col": 17,
        "offset": 8421
      },
      "end": {
        "line": 270,
        "col": 53,
        "offset": 8457
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_12.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2222
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2258
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_12.c",
      "start": {
        "line": 192,
        "col": 17,
        "offset": 5858
      },
      "end": {
        "line": 192,
        "col": 53,
        "offset": 5894
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_12.c",
      "start": {
        "line": 264,
        "col": 17,
        "offset": 8269
      },
      "end": {
        "line": 264,
        "col": 53,
        "offset": 8305
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_13.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2239
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2275
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_13.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5194
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5230
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_13.c",
      "start": {
        "line": 270,
        "col": 17,
        "offset": 8427
      },
      "end": {
        "line": 270,
        "col": 53,
        "offset": 8463
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_14.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2218
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2254
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_14.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5145
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5181
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_14.c",
      "start": {
        "line": 270,
        "col": 17,
        "offset": 8364
      },
      "end": {
        "line": 270,
        "col": 53,
        "offset": 8400
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_15.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2119
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2155
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_15.c",
      "start": {
        "line": 182,
        "col": 13,
        "offset": 5121
      },
      "end": {
        "line": 182,
        "col": 49,
        "offset": 5157
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_15.c",
      "start": {
        "line": 290,
        "col": 13,
        "offset": 8286
      },
      "end": {
        "line": 290,
        "col": 49,
        "offset": 8322
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_16.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2178
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2214
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_16.c",
      "start": {
        "line": 171,
        "col": 17,
        "offset": 5115
      },
      "end": {
        "line": 171,
        "col": 53,
        "offset": 5151
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_17.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2207
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2243
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_17.c",
      "start": {
        "line": 171,
        "col": 17,
        "offset": 5124
      },
      "end": {
        "line": 171,
        "col": 53,
        "offset": 5160
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_18.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2103
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2139
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_18.c",
      "start": {
        "line": 167,
        "col": 13,
        "offset": 4727
      },
      "end": {
        "line": 167,
        "col": 49,
        "offset": 4763
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_21.c",
      "start": {
        "line": 90,
        "col": 13,
        "offset": 2568
      },
      "end": {
        "line": 90,
        "col": 49,
        "offset": 2604
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_21.c",
      "start": {
        "line": 203,
        "col": 13,
        "offset": 5838
      },
      "end": {
        "line": 203,
        "col": 49,
        "offset": 5874
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_21.c",
      "start": {
        "line": 302,
        "col": 13,
        "offset": 8745
      },
      "end": {
        "line": 302,
        "col": 49,
        "offset": 8781
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_22a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2404
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2440
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_22a.c",
      "start": {
        "line": 169,
        "col": 13,
        "offset": 5352
      },
      "end": {
        "line": 169,
        "col": 49,
        "offset": 5388
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_22a.c",
      "start": {
        "line": 250,
        "col": 13,
        "offset": 7937
      },
      "end": {
        "line": 250,
        "col": 49,
        "offset": 7973
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_31.c",
      "start": {
        "line": 74,
        "col": 13,
        "offset": 2102
      },
      "end": {
        "line": 74,
        "col": 49,
        "offset": 2138
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_31.c",
      "start": {
        "line": 185,
        "col": 13,
        "offset": 5289
      },
      "end": {
        "line": 185,
        "col": 49,
        "offset": 5325
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_32.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2300
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2336
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_32.c",
      "start": {
        "line": 199,
        "col": 17,
        "offset": 5945
      },
      "end": {
        "line": 199,
        "col": 53,
        "offset": 5981
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_34.c",
      "start": {
        "line": 81,
        "col": 13,
        "offset": 2360
      },
      "end": {
        "line": 81,
        "col": 49,
        "offset": 2396
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_34.c",
      "start": {
        "line": 194,
        "col": 13,
        "offset": 5731
      },
      "end": {
        "line": 194,
        "col": 49,
        "offset": 5767
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_41.c",
      "start": {
        "line": 84,
        "col": 13,
        "offset": 2384
      },
      "end": {
        "line": 84,
        "col": 49,
        "offset": 2420
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_41.c",
      "start": {
        "line": 204,
        "col": 13,
        "offset": 5678
      },
      "end": {
        "line": 204,
        "col": 49,
        "offset": 5714
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_42.c",
      "start": {
        "line": 71,
        "col": 13,
        "offset": 2032
      },
      "end": {
        "line": 71,
        "col": 49,
        "offset": 2068
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_42.c",
      "start": {
        "line": 186,
        "col": 13,
        "offset": 5249
      },
      "end": {
        "line": 186,
        "col": 49,
        "offset": 5285
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_44.c",
      "start": {
        "line": 86,
        "col": 13,
        "offset": 2500
      },
      "end": {
        "line": 86,
        "col": 49,
        "offset": 2536
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_44.c",
      "start": {
        "line": 209,
        "col": 13,
        "offset": 5914
      },
      "end": {
        "line": 209,
        "col": 49,
        "offset": 5950
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_45.c",
      "start": {
        "line": 89,
        "col": 13,
        "offset": 2707
      },
      "end": {
        "line": 89,
        "col": 49,
        "offset": 2743
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_45.c",
      "start": {
        "line": 213,
        "col": 13,
        "offset": 6305
      },
      "end": {
        "line": 213,
        "col": 49,
        "offset": 6341
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_51a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2256
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2292
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_51a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5157
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5193
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_52a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2273
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2309
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_52a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5174
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5210
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_53a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2300
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2336
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_53a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5201
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5237
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_54a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2301
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2337
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_54a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5202
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5238
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_61b.c",
      "start": {
        "line": 71,
        "col": 13,
        "offset": 2085
      },
      "end": {
        "line": 71,
        "col": 49,
        "offset": 2121
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_61b.c",
      "start": {
        "line": 158,
        "col": 13,
        "offset": 4706
      },
      "end": {
        "line": 158,
        "col": 49,
        "offset": 4742
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_63a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2257
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2293
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_63a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5164
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5200
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_64a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2267
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2303
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_64a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5190
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5226
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_65a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2429
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2465
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_65a.c",
      "start": {
        "line": 179,
        "col": 13,
        "offset": 5446
      },
      "end": {
        "line": 179,
        "col": 49,
        "offset": 5482
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_66a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2283
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2319
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_66a.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5335
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5371
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_67a.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2580
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2616
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_67a.c",
      "start": {
        "line": 184,
        "col": 13,
        "offset": 5851
      },
      "end": {
        "line": 184,
        "col": 49,
        "offset": 5887
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_68a.c",
      "start": {
        "line": 81,
        "col": 13,
        "offset": 2471
      },
      "end": {
        "line": 81,
        "col": 49,
        "offset": 2507
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_68a.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5536
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5572
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_01.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2038
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2074
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_01.c",
      "start": {
        "line": 177,
        "col": 13,
        "offset": 4921
      },
      "end": {
        "line": 177,
        "col": 49,
        "offset": 4957
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_02.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2165
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2201
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_02.c",
      "start": {
        "line": 170,
        "col": 17,
        "offset": 4988
      },
      "end": {
        "line": 170,
        "col": 53,
        "offset": 5024
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_02.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8101
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8137
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_03.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2174
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2210
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_03.c",
      "start": {
        "line": 170,
        "col": 17,
        "offset": 5009
      },
      "end": {
        "line": 170,
        "col": 53,
        "offset": 5045
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_03.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8128
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8164
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_04.c",
      "start": {
        "line": 84,
        "col": 17,
        "offset": 2485
      },
      "end": {
        "line": 84,
        "col": 53,
        "offset": 2521
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_04.c",
      "start": {
        "line": 176,
        "col": 17,
        "offset": 5373
      },
      "end": {
        "line": 176,
        "col": 53,
        "offset": 5409
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_04.c",
      "start": {
        "line": 274,
        "col": 17,
        "offset": 8519
      },
      "end": {
        "line": 274,
        "col": 53,
        "offset": 8555
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_05.c",
      "start": {
        "line": 84,
        "col": 17,
        "offset": 2484
      },
      "end": {
        "line": 84,
        "col": 53,
        "offset": 2520
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_05.c",
      "start": {
        "line": 176,
        "col": 17,
        "offset": 5344
      },
      "end": {
        "line": 176,
        "col": 53,
        "offset": 5380
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_05.c",
      "start": {
        "line": 274,
        "col": 17,
        "offset": 8476
      },
      "end": {
        "line": 274,
        "col": 53,
        "offset": 8512
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_06.c",
      "start": {
        "line": 83,
        "col": 17,
        "offset": 2416
      },
      "end": {
        "line": 83,
        "col": 53,
        "offset": 2452
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_06.c",
      "start": {
        "line": 175,
        "col": 17,
        "offset": 5315
      },
      "end": {
        "line": 175,
        "col": 53,
        "offset": 5351
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_06.c",
      "start": {
        "line": 273,
        "col": 17,
        "offset": 8466
      },
      "end": {
        "line": 273,
        "col": 53,
        "offset": 8502
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_07.c",
      "start": {
        "line": 83,
        "col": 17,
        "offset": 2424
      },
      "end": {
        "line": 83,
        "col": 53,
        "offset": 2460
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_07.c",
      "start": {
        "line": 175,
        "col": 17,
        "offset": 5295
      },
      "end": {
        "line": 175,
        "col": 53,
        "offset": 5331
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_07.c",
      "start": {
        "line": 273,
        "col": 17,
        "offset": 8432
      },
      "end": {
        "line": 273,
        "col": 53,
        "offset": 8468
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_08.c",
      "start": {
        "line": 91,
        "col": 17,
        "offset": 2498
      },
      "end": {
        "line": 91,
        "col": 53,
        "offset": 2534
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_08.c",
      "start": {
        "line": 183,
        "col": 17,
        "offset": 5394
      },
      "end": {
        "line": 183,
        "col": 53,
        "offset": 5430
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_08.c",
      "start": {
        "line": 281,
        "col": 17,
        "offset": 8544
      },
      "end": {
        "line": 281,
        "col": 53,
        "offset": 8580
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_09.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2214
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2250
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_09.c",
      "start": {
        "line": 170,
        "col": 17,
        "offset": 5102
      },
      "end": {
        "line": 170,
        "col": 53,
        "offset": 5138
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_09.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8248
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8284
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_10.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2193
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2229
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_10.c",
      "start": {
        "line": 170,
        "col": 17,
        "offset": 5053
      },
      "end": {
        "line": 170,
        "col": 53,
        "offset": 5089
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_10.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8185
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8221
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_11.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2220
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2256
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_11.c",
      "start": {
        "line": 170,
        "col": 17,
        "offset": 5116
      },
      "end": {
        "line": 170,
        "col": 53,
        "offset": 5152
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_11.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8266
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8302
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_12.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2205
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2241
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_12.c",
      "start": {
        "line": 190,
        "col": 17,
        "offset": 5703
      },
      "end": {
        "line": 190,
        "col": 53,
        "offset": 5739
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_12.c",
      "start": {
        "line": 262,
        "col": 17,
        "offset": 8114
      },
      "end": {
        "line": 262,
        "col": 53,
        "offset": 8150
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_13.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2222
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2258
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_13.c",
      "start": {
        "line": 170,
        "col": 17,
        "offset": 5121
      },
      "end": {
        "line": 170,
        "col": 53,
        "offset": 5157
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_13.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8272
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8308
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_14.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2201
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2237
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_14.c",
      "start": {
        "line": 170,
        "col": 17,
        "offset": 5072
      },
      "end": {
        "line": 170,
        "col": 53,
        "offset": 5108
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_14.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8209
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8245
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_15.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2102
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2138
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_15.c",
      "start": {
        "line": 183,
        "col": 13,
        "offset": 5024
      },
      "end": {
        "line": 183,
        "col": 49,
        "offset": 5060
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_15.c",
      "start": {
        "line": 288,
        "col": 13,
        "offset": 8107
      },
      "end": {
        "line": 288,
        "col": 49,
        "offset": 8143
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_16.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2161
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2197
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_16.c",
      "start": {
        "line": 172,
        "col": 17,
        "offset": 5042
      },
      "end": {
        "line": 172,
        "col": 53,
        "offset": 5078
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_17.c",
      "start": {
        "line": 79,
        "col": 17,
        "offset": 2190
      },
      "end": {
        "line": 79,
        "col": 53,
        "offset": 2226
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_17.c",
      "start": {
        "line": 172,
        "col": 17,
        "offset": 5051
      },
      "end": {
        "line": 172,
        "col": 53,
        "offset": 5087
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_18.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2086
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2122
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_18.c",
      "start": {
        "line": 168,
        "col": 13,
        "offset": 4658
      },
      "end": {
        "line": 168,
        "col": 49,
        "offset": 4694
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_21.c",
      "start": {
        "line": 91,
        "col": 13,
        "offset": 2495
      },
      "end": {
        "line": 91,
        "col": 49,
        "offset": 2531
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_21.c",
      "start": {
        "line": 201,
        "col": 13,
        "offset": 5683
      },
      "end": {
        "line": 201,
        "col": 49,
        "offset": 5719
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_21.c",
      "start": {
        "line": 297,
        "col": 13,
        "offset": 8508
      },
      "end": {
        "line": 297,
        "col": 49,
        "offset": 8544
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_22a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2362
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2398
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_22a.c",
      "start": {
        "line": 169,
        "col": 13,
        "offset": 5298
      },
      "end": {
        "line": 169,
        "col": 49,
        "offset": 5334
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_22a.c",
      "start": {
        "line": 250,
        "col": 13,
        "offset": 7877
      },
      "end": {
        "line": 250,
        "col": 49,
        "offset": 7913
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_31.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2085
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2121
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_31.c",
      "start": {
        "line": 185,
        "col": 13,
        "offset": 5160
      },
      "end": {
        "line": 185,
        "col": 49,
        "offset": 5196
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_32.c",
      "start": {
        "line": 80,
        "col": 17,
        "offset": 2283
      },
      "end": {
        "line": 80,
        "col": 53,
        "offset": 2319
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_32.c",
      "start": {
        "line": 199,
        "col": 17,
        "offset": 5816
      },
      "end": {
        "line": 199,
        "col": 53,
        "offset": 5852
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_34.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2339
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2375
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_34.c",
      "start": {
        "line": 194,
        "col": 13,
        "offset": 5594
      },
      "end": {
        "line": 194,
        "col": 49,
        "offset": 5630
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_41.c",
      "start": {
        "line": 85,
        "col": 13,
        "offset": 2315
      },
      "end": {
        "line": 85,
        "col": 49,
        "offset": 2351
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_41.c",
      "start": {
        "line": 201,
        "col": 13,
        "offset": 5487
      },
      "end": {
        "line": 201,
        "col": 49,
        "offset": 5523
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_42.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 2017
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2053
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_42.c",
      "start": {
        "line": 186,
        "col": 13,
        "offset": 5128
      },
      "end": {
        "line": 186,
        "col": 49,
        "offset": 5164
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_44.c",
      "start": {
        "line": 87,
        "col": 13,
        "offset": 2431
      },
      "end": {
        "line": 87,
        "col": 49,
        "offset": 2467
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_44.c",
      "start": {
        "line": 206,
        "col": 13,
        "offset": 5723
      },
      "end": {
        "line": 206,
        "col": 49,
        "offset": 5759
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_45.c",
      "start": {
        "line": 90,
        "col": 13,
        "offset": 2630
      },
      "end": {
        "line": 90,
        "col": 49,
        "offset": 2666
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_45.c",
      "start": {
        "line": 210,
        "col": 13,
        "offset": 6098
      },
      "end": {
        "line": 210,
        "col": 49,
        "offset": 6134
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_51a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2237
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2273
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_51a.c",
      "start": {
        "line": 176,
        "col": 13,
        "offset": 5130
      },
      "end": {
        "line": 176,
        "col": 49,
        "offset": 5166
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_52a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2254
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2290
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_52a.c",
      "start": {
        "line": 176,
        "col": 13,
        "offset": 5147
      },
      "end": {
        "line": 176,
        "col": 49,
        "offset": 5183
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_53a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2281
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2317
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_53a.c",
      "start": {
        "line": 176,
        "col": 13,
        "offset": 5174
      },
      "end": {
        "line": 176,
        "col": 49,
        "offset": 5210
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_54a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2282
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2318
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_54a.c",
      "start": {
        "line": 176,
        "col": 13,
        "offset": 5175
      },
      "end": {
        "line": 176,
        "col": 49,
        "offset": 5211
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_61b.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 2068
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2104
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_61b.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4685
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4721
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_63a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2238
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2274
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_63a.c",
      "start": {
        "line": 176,
        "col": 13,
        "offset": 5137
      },
      "end": {
        "line": 176,
        "col": 49,
        "offset": 5173
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_64a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2248
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2284
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_64a.c",
      "start": {
        "line": 176,
        "col": 13,
        "offset": 5163
      },
      "end": {
        "line": 176,
        "col": 49,
        "offset": 5199
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_65a.c",
      "start": {
        "line": 81,
        "col": 13,
        "offset": 2408
      },
      "end": {
        "line": 81,
        "col": 49,
        "offset": 2444
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_65a.c",
      "start": {
        "line": 181,
        "col": 13,
        "offset": 5417
      },
      "end": {
        "line": 181,
        "col": 49,
        "offset": 5453
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_66a.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2264
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2300
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_66a.c",
      "start": {
        "line": 182,
        "col": 13,
        "offset": 5308
      },
      "end": {
        "line": 182,
        "col": 49,
        "offset": 5344
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_67a.c",
      "start": {
        "line": 85,
        "col": 13,
        "offset": 2553
      },
      "end": {
        "line": 85,
        "col": 49,
        "offset": 2589
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_67a.c",
      "start": {
        "line": 186,
        "col": 13,
        "offset": 5808
      },
      "end": {
        "line": 186,
        "col": 49,
        "offset": 5844
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_68a.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2446
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2482
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_68a.c",
      "start": {
        "line": 182,
        "col": 13,
        "offset": 5499
      },
      "end": {
        "line": 182,
        "col": 49,
        "offset": 5535
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_01.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 2014
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2050
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_01.c",
      "start": {
        "line": 163,
        "col": 13,
        "offset": 4593
      },
      "end": {
        "line": 163,
        "col": 49,
        "offset": 4629
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_02.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2137
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2173
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_02.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4602
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4638
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_02.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7317
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7353
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_03.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2146
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2182
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_03.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4623
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4659
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_03.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7344
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7380
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_04.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2457
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2493
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_04.c",
      "start": {
        "line": 161,
        "col": 17,
        "offset": 4987
      },
      "end": {
        "line": 161,
        "col": 53,
        "offset": 5023
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_04.c",
      "start": {
        "line": 247,
        "col": 17,
        "offset": 7735
      },
      "end": {
        "line": 247,
        "col": 53,
        "offset": 7771
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_05.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2456
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2492
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_05.c",
      "start": {
        "line": 161,
        "col": 17,
        "offset": 4958
      },
      "end": {
        "line": 161,
        "col": 53,
        "offset": 4994
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_05.c",
      "start": {
        "line": 247,
        "col": 17,
        "offset": 7692
      },
      "end": {
        "line": 247,
        "col": 53,
        "offset": 7728
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_06.c",
      "start": {
        "line": 80,
        "col": 17,
        "offset": 2388
      },
      "end": {
        "line": 80,
        "col": 53,
        "offset": 2424
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_06.c",
      "start": {
        "line": 160,
        "col": 17,
        "offset": 4929
      },
      "end": {
        "line": 160,
        "col": 53,
        "offset": 4965
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_06.c",
      "start": {
        "line": 246,
        "col": 17,
        "offset": 7682
      },
      "end": {
        "line": 246,
        "col": 53,
        "offset": 7718
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_07.c",
      "start": {
        "line": 80,
        "col": 17,
        "offset": 2396
      },
      "end": {
        "line": 80,
        "col": 53,
        "offset": 2432
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_07.c",
      "start": {
        "line": 160,
        "col": 17,
        "offset": 4909
      },
      "end": {
        "line": 160,
        "col": 53,
        "offset": 4945
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_07.c",
      "start": {
        "line": 246,
        "col": 17,
        "offset": 7648
      },
      "end": {
        "line": 246,
        "col": 53,
        "offset": 7684
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_08.c",
      "start": {
        "line": 88,
        "col": 17,
        "offset": 2470
      },
      "end": {
        "line": 88,
        "col": 53,
        "offset": 2506
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_08.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 5008
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 5044
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_08.c",
      "start": {
        "line": 254,
        "col": 17,
        "offset": 7760
      },
      "end": {
        "line": 254,
        "col": 53,
        "offset": 7796
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_09.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2186
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2222
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_09.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4716
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4752
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_09.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7464
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7500
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_10.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2165
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2201
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_10.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4667
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4703
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_10.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7401
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7437
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_11.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2192
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2228
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_11.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4730
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4766
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_11.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7482
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7518
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_12.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2177
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2213
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_12.c",
      "start": {
        "line": 176,
        "col": 17,
        "offset": 5287
      },
      "end": {
        "line": 176,
        "col": 53,
        "offset": 5323
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_12.c",
      "start": {
        "line": 235,
        "col": 17,
        "offset": 7330
      },
      "end": {
        "line": 235,
        "col": 53,
        "offset": 7366
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_13.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2194
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2230
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_13.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4735
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4771
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_13.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7488
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7524
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_14.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2173
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2209
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_14.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4686
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4722
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_14.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7425
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7461
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_15.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2078
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2114
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_15.c",
      "start": {
        "line": 168,
        "col": 13,
        "offset": 4690
      },
      "end": {
        "line": 168,
        "col": 49,
        "offset": 4726
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_15.c",
      "start": {
        "line": 261,
        "col": 13,
        "offset": 7427
      },
      "end": {
        "line": 261,
        "col": 49,
        "offset": 7463
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_16.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2133
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2169
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_16.c",
      "start": {
        "line": 157,
        "col": 17,
        "offset": 4656
      },
      "end": {
        "line": 157,
        "col": 53,
        "offset": 4692
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_17.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2162
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2198
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_17.c",
      "start": {
        "line": 157,
        "col": 17,
        "offset": 4665
      },
      "end": {
        "line": 157,
        "col": 53,
        "offset": 4701
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_18.c",
      "start": {
        "line": 75,
        "col": 13,
        "offset": 2062
      },
      "end": {
        "line": 75,
        "col": 49,
        "offset": 2098
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_18.c",
      "start": {
        "line": 153,
        "col": 13,
        "offset": 4324
      },
      "end": {
        "line": 153,
        "col": 49,
        "offset": 4360
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_21.c",
      "start": {
        "line": 89,
        "col": 13,
        "offset": 2481
      },
      "end": {
        "line": 89,
        "col": 49,
        "offset": 2517
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_21.c",
      "start": {
        "line": 187,
        "col": 13,
        "offset": 5323
      },
      "end": {
        "line": 187,
        "col": 49,
        "offset": 5359
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_21.c",
      "start": {
        "line": 271,
        "col": 13,
        "offset": 7802
      },
      "end": {
        "line": 271,
        "col": 49,
        "offset": 7838
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_22a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2363
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2399
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_22a.c",
      "start": {
        "line": 155,
        "col": 13,
        "offset": 4995
      },
      "end": {
        "line": 155,
        "col": 49,
        "offset": 5031
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_22a.c",
      "start": {
        "line": 223,
        "col": 13,
        "offset": 7264
      },
      "end": {
        "line": 223,
        "col": 49,
        "offset": 7300
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_31.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 2061
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2097
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_31.c",
      "start": {
        "line": 171,
        "col": 13,
        "offset": 4840
      },
      "end": {
        "line": 171,
        "col": 49,
        "offset": 4876
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_32.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2255
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2291
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_32.c",
      "start": {
        "line": 185,
        "col": 17,
        "offset": 5440
      },
      "end": {
        "line": 185,
        "col": 53,
        "offset": 5476
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_34.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2319
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2355
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_34.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5282
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5318
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_41.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2297
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2333
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_41.c",
      "start": {
        "line": 188,
        "col": 13,
        "offset": 5125
      },
      "end": {
        "line": 188,
        "col": 49,
        "offset": 5161
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_42.c",
      "start": {
        "line": 70,
        "col": 13,
        "offset": 1991
      },
      "end": {
        "line": 70,
        "col": 49,
        "offset": 2027
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_42.c",
      "start": {
        "line": 172,
        "col": 13,
        "offset": 4800
      },
      "end": {
        "line": 172,
        "col": 49,
        "offset": 4836
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_44.c",
      "start": {
        "line": 85,
        "col": 13,
        "offset": 2413
      },
      "end": {
        "line": 85,
        "col": 49,
        "offset": 2449
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_44.c",
      "start": {
        "line": 193,
        "col": 13,
        "offset": 5361
      },
      "end": {
        "line": 193,
        "col": 49,
        "offset": 5397
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_45.c",
      "start": {
        "line": 88,
        "col": 13,
        "offset": 2620
      },
      "end": {
        "line": 88,
        "col": 49,
        "offset": 2656
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_45.c",
      "start": {
        "line": 197,
        "col": 13,
        "offset": 5752
      },
      "end": {
        "line": 197,
        "col": 49,
        "offset": 5788
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_51a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2215
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2251
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_51a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4800
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4836
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_52a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2232
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2268
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_52a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4817
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4853
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_53a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2259
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2295
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_53a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4844
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4880
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_54a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2260
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2296
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_54a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4845
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4881
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_61b.c",
      "start": {
        "line": 70,
        "col": 13,
        "offset": 2044
      },
      "end": {
        "line": 70,
        "col": 49,
        "offset": 2080
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_61b.c",
      "start": {
        "line": 144,
        "col": 13,
        "offset": 4349
      },
      "end": {
        "line": 144,
        "col": 49,
        "offset": 4385
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_63a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2216
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2252
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_63a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4807
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4843
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_64a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2226
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2262
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_64a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4833
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4869
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_65a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2388
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2424
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_65a.c",
      "start": {
        "line": 165,
        "col": 13,
        "offset": 5089
      },
      "end": {
        "line": 165,
        "col": 49,
        "offset": 5125
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_66a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2242
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2278
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_66a.c",
      "start": {
        "line": 166,
        "col": 13,
        "offset": 4978
      },
      "end": {
        "line": 166,
        "col": 49,
        "offset": 5014
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_67a.c",
      "start": {
        "line": 82,
        "col": 13,
        "offset": 2539
      },
      "end": {
        "line": 82,
        "col": 49,
        "offset": 2575
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_67a.c",
      "start": {
        "line": 170,
        "col": 13,
        "offset": 5494
      },
      "end": {
        "line": 170,
        "col": 49,
        "offset": 5530
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_68a.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2430
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2466
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_68a.c",
      "start": {
        "line": 166,
        "col": 13,
        "offset": 5179
      },
      "end": {
        "line": 166,
        "col": 49,
        "offset": 5215
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_01.c",
      "start": {
        "line": 74,
        "col": 13,
        "offset": 2030
      },
      "end": {
        "line": 74,
        "col": 49,
        "offset": 2066
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_01.c",
      "start": {
        "line": 177,
        "col": 13,
        "offset": 4925
      },
      "end": {
        "line": 177,
        "col": 49,
        "offset": 4961
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_02.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2157
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2193
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_02.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 4990
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5026
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_02.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8073
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8109
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_03.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2166
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2202
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_03.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5011
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5047
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_03.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8100
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8136
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_04.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2477
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2513
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_04.c",
      "start": {
        "line": 175,
        "col": 17,
        "offset": 5375
      },
      "end": {
        "line": 175,
        "col": 53,
        "offset": 5411
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_04.c",
      "start": {
        "line": 274,
        "col": 17,
        "offset": 8491
      },
      "end": {
        "line": 274,
        "col": 53,
        "offset": 8527
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_05.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2476
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2512
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_05.c",
      "start": {
        "line": 175,
        "col": 17,
        "offset": 5346
      },
      "end": {
        "line": 175,
        "col": 53,
        "offset": 5382
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_05.c",
      "start": {
        "line": 274,
        "col": 17,
        "offset": 8448
      },
      "end": {
        "line": 274,
        "col": 53,
        "offset": 8484
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_06.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2408
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2444
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_06.c",
      "start": {
        "line": 174,
        "col": 17,
        "offset": 5317
      },
      "end": {
        "line": 174,
        "col": 53,
        "offset": 5353
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_06.c",
      "start": {
        "line": 273,
        "col": 17,
        "offset": 8438
      },
      "end": {
        "line": 273,
        "col": 53,
        "offset": 8474
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_07.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2416
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2452
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_07.c",
      "start": {
        "line": 174,
        "col": 17,
        "offset": 5297
      },
      "end": {
        "line": 174,
        "col": 53,
        "offset": 5333
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_07.c",
      "start": {
        "line": 273,
        "col": 17,
        "offset": 8404
      },
      "end": {
        "line": 273,
        "col": 53,
        "offset": 8440
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_08.c",
      "start": {
        "line": 89,
        "col": 17,
        "offset": 2490
      },
      "end": {
        "line": 89,
        "col": 53,
        "offset": 2526
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_08.c",
      "start": {
        "line": 182,
        "col": 17,
        "offset": 5396
      },
      "end": {
        "line": 182,
        "col": 53,
        "offset": 5432
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_08.c",
      "start": {
        "line": 281,
        "col": 17,
        "offset": 8516
      },
      "end": {
        "line": 281,
        "col": 53,
        "offset": 8552
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_09.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2206
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2242
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_09.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5104
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5140
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_09.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8220
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8256
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_10.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2185
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2221
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_10.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5055
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5091
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_10.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8157
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8193
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_11.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2212
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2248
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_11.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5118
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5154
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_11.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8238
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8274
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_12.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2197
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2233
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_12.c",
      "start": {
        "line": 190,
        "col": 17,
        "offset": 5675
      },
      "end": {
        "line": 190,
        "col": 53,
        "offset": 5711
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_12.c",
      "start": {
        "line": 262,
        "col": 17,
        "offset": 8086
      },
      "end": {
        "line": 262,
        "col": 53,
        "offset": 8122
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_13.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2214
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2250
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_13.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5123
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5159
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_13.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8244
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8280
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_14.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2193
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2229
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_14.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5074
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5110
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_14.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8181
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8217
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_15.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2094
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2130
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_15.c",
      "start": {
        "line": 182,
        "col": 13,
        "offset": 5022
      },
      "end": {
        "line": 182,
        "col": 49,
        "offset": 5058
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_15.c",
      "start": {
        "line": 288,
        "col": 13,
        "offset": 8075
      },
      "end": {
        "line": 288,
        "col": 49,
        "offset": 8111
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_16.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2153
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2189
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_16.c",
      "start": {
        "line": 171,
        "col": 17,
        "offset": 5044
      },
      "end": {
        "line": 171,
        "col": 53,
        "offset": 5080
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_17.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2182
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2218
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_17.c",
      "start": {
        "line": 171,
        "col": 17,
        "offset": 5053
      },
      "end": {
        "line": 171,
        "col": 53,
        "offset": 5089
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_18.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2078
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2114
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_18.c",
      "start": {
        "line": 167,
        "col": 13,
        "offset": 4656
      },
      "end": {
        "line": 167,
        "col": 49,
        "offset": 4692
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_21.c",
      "start": {
        "line": 90,
        "col": 13,
        "offset": 2497
      },
      "end": {
        "line": 90,
        "col": 49,
        "offset": 2533
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_21.c",
      "start": {
        "line": 201,
        "col": 13,
        "offset": 5655
      },
      "end": {
        "line": 201,
        "col": 49,
        "offset": 5691
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_21.c",
      "start": {
        "line": 298,
        "col": 13,
        "offset": 8450
      },
      "end": {
        "line": 298,
        "col": 49,
        "offset": 8486
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_22a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2377
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2413
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_22a.c",
      "start": {
        "line": 169,
        "col": 13,
        "offset": 5319
      },
      "end": {
        "line": 169,
        "col": 49,
        "offset": 5355
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_22a.c",
      "start": {
        "line": 250,
        "col": 13,
        "offset": 7901
      },
      "end": {
        "line": 250,
        "col": 49,
        "offset": 7937
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_31.c",
      "start": {
        "line": 74,
        "col": 13,
        "offset": 2077
      },
      "end": {
        "line": 74,
        "col": 49,
        "offset": 2113
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_31.c",
      "start": {
        "line": 185,
        "col": 13,
        "offset": 5172
      },
      "end": {
        "line": 185,
        "col": 49,
        "offset": 5208
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_32.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2275
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2311
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_32.c",
      "start": {
        "line": 199,
        "col": 17,
        "offset": 5828
      },
      "end": {
        "line": 199,
        "col": 53,
        "offset": 5864
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_34.c",
      "start": {
        "line": 81,
        "col": 13,
        "offset": 2333
      },
      "end": {
        "line": 81,
        "col": 49,
        "offset": 2369
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_34.c",
      "start": {
        "line": 194,
        "col": 13,
        "offset": 5610
      },
      "end": {
        "line": 194,
        "col": 49,
        "offset": 5646
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_41.c",
      "start": {
        "line": 84,
        "col": 13,
        "offset": 2313
      },
      "end": {
        "line": 84,
        "col": 49,
        "offset": 2349
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_41.c",
      "start": {
        "line": 202,
        "col": 13,
        "offset": 5457
      },
      "end": {
        "line": 202,
        "col": 49,
        "offset": 5493
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_42.c",
      "start": {
        "line": 71,
        "col": 13,
        "offset": 2008
      },
      "end": {
        "line": 71,
        "col": 49,
        "offset": 2044
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_42.c",
      "start": {
        "line": 186,
        "col": 13,
        "offset": 5132
      },
      "end": {
        "line": 186,
        "col": 49,
        "offset": 5168
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_44.c",
      "start": {
        "line": 86,
        "col": 13,
        "offset": 2429
      },
      "end": {
        "line": 86,
        "col": 49,
        "offset": 2465
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_44.c",
      "start": {
        "line": 207,
        "col": 13,
        "offset": 5693
      },
      "end": {
        "line": 207,
        "col": 49,
        "offset": 5729
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_45.c",
      "start": {
        "line": 89,
        "col": 13,
        "offset": 2632
      },
      "end": {
        "line": 89,
        "col": 49,
        "offset": 2668
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_45.c",
      "start": {
        "line": 211,
        "col": 13,
        "offset": 6076
      },
      "end": {
        "line": 211,
        "col": 49,
        "offset": 6112
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_51a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2230
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2266
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_51a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5127
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5163
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_52a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2247
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2283
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_52a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5144
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5180
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_53a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2274
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2310
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_53a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5171
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5207
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_54a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2275
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2311
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_54a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5172
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5208
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_61b.c",
      "start": {
        "line": 71,
        "col": 13,
        "offset": 2060
      },
      "end": {
        "line": 71,
        "col": 49,
        "offset": 2096
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_61b.c",
      "start": {
        "line": 158,
        "col": 13,
        "offset": 4679
      },
      "end": {
        "line": 158,
        "col": 49,
        "offset": 4715
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_63a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2231
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2267
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_63a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5134
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5170
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_64a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2241
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2277
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_64a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5160
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5196
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_65a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2402
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2438
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_65a.c",
      "start": {
        "line": 179,
        "col": 13,
        "offset": 5415
      },
      "end": {
        "line": 179,
        "col": 49,
        "offset": 5451
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_66a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2257
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2293
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_66a.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5305
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5341
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_67a.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2550
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2586
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_67a.c",
      "start": {
        "line": 184,
        "col": 13,
        "offset": 5813
      },
      "end": {
        "line": 184,
        "col": 49,
        "offset": 5849
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_68a.c",
      "start": {
        "line": 81,
        "col": 13,
        "offset": 2442
      },
      "end": {
        "line": 81,
        "col": 49,
        "offset": 2478
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_68a.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5501
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5537
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_01.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 2012
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2048
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_01.c",
      "start": {
        "line": 163,
        "col": 13,
        "offset": 4591
      },
      "end": {
        "line": 163,
        "col": 49,
        "offset": 4627
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_02.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2135
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2171
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_02.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4600
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4636
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_02.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7315
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7351
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_03.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2144
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2180
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_03.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4621
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4657
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_03.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7342
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7378
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_04.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2455
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2491
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_04.c",
      "start": {
        "line": 161,
        "col": 17,
        "offset": 4985
      },
      "end": {
        "line": 161,
        "col": 53,
        "offset": 5021
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_04.c",
      "start": {
        "line": 247,
        "col": 17,
        "offset": 7733
      },
      "end": {
        "line": 247,
        "col": 53,
        "offset": 7769
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_05.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2454
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2490
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_05.c",
      "start": {
        "line": 161,
        "col": 17,
        "offset": 4956
      },
      "end": {
        "line": 161,
        "col": 53,
        "offset": 4992
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_05.c",
      "start": {
        "line": 247,
        "col": 17,
        "offset": 7690
      },
      "end": {
        "line": 247,
        "col": 53,
        "offset": 7726
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_06.c",
      "start": {
        "line": 80,
        "col": 17,
        "offset": 2386
      },
      "end": {
        "line": 80,
        "col": 53,
        "offset": 2422
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_06.c",
      "start": {
        "line": 160,
        "col": 17,
        "offset": 4927
      },
      "end": {
        "line": 160,
        "col": 53,
        "offset": 4963
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_06.c",
      "start": {
        "line": 246,
        "col": 17,
        "offset": 7680
      },
      "end": {
        "line": 246,
        "col": 53,
        "offset": 7716
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_07.c",
      "start": {
        "line": 80,
        "col": 17,
        "offset": 2394
      },
      "end": {
        "line": 80,
        "col": 53,
        "offset": 2430
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_07.c",
      "start": {
        "line": 160,
        "col": 17,
        "offset": 4907
      },
      "end": {
        "line": 160,
        "col": 53,
        "offset": 4943
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_07.c",
      "start": {
        "line": 246,
        "col": 17,
        "offset": 7646
      },
      "end": {
        "line": 246,
        "col": 53,
        "offset": 7682
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_08.c",
      "start": {
        "line": 88,
        "col": 17,
        "offset": 2468
      },
      "end": {
        "line": 88,
        "col": 53,
        "offset": 2504
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_08.c",
      "start": {
        "line": 168,
        "col": 17,
        "offset": 5006
      },
      "end": {
        "line": 168,
        "col": 53,
        "offset": 5042
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_08.c",
      "start": {
        "line": 254,
        "col": 17,
        "offset": 7758
      },
      "end": {
        "line": 254,
        "col": 53,
        "offset": 7794
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_09.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2184
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2220
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_09.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4714
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4750
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_09.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7462
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7498
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_10.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2163
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2199
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_10.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4665
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4701
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_10.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7399
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7435
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_11.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2190
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2226
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_11.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4728
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4764
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_11.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7480
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7516
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_12.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2175
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2211
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_12.c",
      "start": {
        "line": 176,
        "col": 17,
        "offset": 5285
      },
      "end": {
        "line": 176,
        "col": 53,
        "offset": 5321
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_12.c",
      "start": {
        "line": 235,
        "col": 17,
        "offset": 7328
      },
      "end": {
        "line": 235,
        "col": 53,
        "offset": 7364
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_13.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2192
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2228
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_13.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4733
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4769
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_13.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7486
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7522
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_14.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2171
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2207
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_14.c",
      "start": {
        "line": 155,
        "col": 17,
        "offset": 4684
      },
      "end": {
        "line": 155,
        "col": 53,
        "offset": 4720
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_14.c",
      "start": {
        "line": 241,
        "col": 17,
        "offset": 7423
      },
      "end": {
        "line": 241,
        "col": 53,
        "offset": 7459
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_15.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2076
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2112
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_15.c",
      "start": {
        "line": 168,
        "col": 13,
        "offset": 4688
      },
      "end": {
        "line": 168,
        "col": 49,
        "offset": 4724
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_15.c",
      "start": {
        "line": 261,
        "col": 13,
        "offset": 7425
      },
      "end": {
        "line": 261,
        "col": 49,
        "offset": 7461
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_16.c",
      "start": {
        "line": 75,
        "col": 17,
        "offset": 2131
      },
      "end": {
        "line": 75,
        "col": 53,
        "offset": 2167
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_16.c",
      "start": {
        "line": 157,
        "col": 17,
        "offset": 4654
      },
      "end": {
        "line": 157,
        "col": 53,
        "offset": 4690
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_17.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2160
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2196
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_17.c",
      "start": {
        "line": 157,
        "col": 17,
        "offset": 4663
      },
      "end": {
        "line": 157,
        "col": 53,
        "offset": 4699
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_18.c",
      "start": {
        "line": 75,
        "col": 13,
        "offset": 2060
      },
      "end": {
        "line": 75,
        "col": 49,
        "offset": 2096
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_18.c",
      "start": {
        "line": 153,
        "col": 13,
        "offset": 4322
      },
      "end": {
        "line": 153,
        "col": 49,
        "offset": 4358
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_21.c",
      "start": {
        "line": 89,
        "col": 13,
        "offset": 2479
      },
      "end": {
        "line": 89,
        "col": 49,
        "offset": 2515
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_21.c",
      "start": {
        "line": 187,
        "col": 13,
        "offset": 5321
      },
      "end": {
        "line": 187,
        "col": 49,
        "offset": 5357
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_21.c",
      "start": {
        "line": 271,
        "col": 13,
        "offset": 7800
      },
      "end": {
        "line": 271,
        "col": 49,
        "offset": 7836
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_22a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2359
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2395
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_22a.c",
      "start": {
        "line": 155,
        "col": 13,
        "offset": 4985
      },
      "end": {
        "line": 155,
        "col": 49,
        "offset": 5021
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_22a.c",
      "start": {
        "line": 223,
        "col": 13,
        "offset": 7251
      },
      "end": {
        "line": 223,
        "col": 49,
        "offset": 7287
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_31.c",
      "start": {
        "line": 73,
        "col": 13,
        "offset": 2059
      },
      "end": {
        "line": 73,
        "col": 49,
        "offset": 2095
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_31.c",
      "start": {
        "line": 171,
        "col": 13,
        "offset": 4838
      },
      "end": {
        "line": 171,
        "col": 49,
        "offset": 4874
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_32.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2253
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2289
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_32.c",
      "start": {
        "line": 185,
        "col": 17,
        "offset": 5438
      },
      "end": {
        "line": 185,
        "col": 53,
        "offset": 5474
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_34.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2315
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2351
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_34.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5276
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5312
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_41.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2295
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2331
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_41.c",
      "start": {
        "line": 188,
        "col": 13,
        "offset": 5123
      },
      "end": {
        "line": 188,
        "col": 49,
        "offset": 5159
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_42.c",
      "start": {
        "line": 70,
        "col": 13,
        "offset": 1990
      },
      "end": {
        "line": 70,
        "col": 49,
        "offset": 2026
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_42.c",
      "start": {
        "line": 172,
        "col": 13,
        "offset": 4798
      },
      "end": {
        "line": 172,
        "col": 49,
        "offset": 4834
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_44.c",
      "start": {
        "line": 85,
        "col": 13,
        "offset": 2411
      },
      "end": {
        "line": 85,
        "col": 49,
        "offset": 2447
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_44.c",
      "start": {
        "line": 193,
        "col": 13,
        "offset": 5359
      },
      "end": {
        "line": 193,
        "col": 49,
        "offset": 5395
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_45.c",
      "start": {
        "line": 88,
        "col": 13,
        "offset": 2614
      },
      "end": {
        "line": 88,
        "col": 49,
        "offset": 2650
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_45.c",
      "start": {
        "line": 197,
        "col": 13,
        "offset": 5742
      },
      "end": {
        "line": 197,
        "col": 49,
        "offset": 5778
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_51a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2212
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2248
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_51a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4793
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4829
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_52a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2229
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2265
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_52a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4810
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4846
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_53a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2256
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2292
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_53a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4837
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4873
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_54a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2257
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2293
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_54a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4838
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4874
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_61b.c",
      "start": {
        "line": 70,
        "col": 13,
        "offset": 2042
      },
      "end": {
        "line": 70,
        "col": 49,
        "offset": 2078
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_61b.c",
      "start": {
        "line": 144,
        "col": 13,
        "offset": 4345
      },
      "end": {
        "line": 144,
        "col": 49,
        "offset": 4381
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_63a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2213
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2249
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_63a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4800
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4836
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_64a.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2223
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2259
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_64a.c",
      "start": {
        "line": 160,
        "col": 13,
        "offset": 4826
      },
      "end": {
        "line": 160,
        "col": 49,
        "offset": 4862
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_65a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2384
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2420
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_65a.c",
      "start": {
        "line": 165,
        "col": 13,
        "offset": 5081
      },
      "end": {
        "line": 165,
        "col": 49,
        "offset": 5117
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_66a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2239
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2275
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_66a.c",
      "start": {
        "line": 166,
        "col": 13,
        "offset": 4971
      },
      "end": {
        "line": 166,
        "col": 49,
        "offset": 5007
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_67a.c",
      "start": {
        "line": 82,
        "col": 13,
        "offset": 2532
      },
      "end": {
        "line": 82,
        "col": 49,
        "offset": 2568
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_67a.c",
      "start": {
        "line": 170,
        "col": 13,
        "offset": 5479
      },
      "end": {
        "line": 170,
        "col": 49,
        "offset": 5515
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_68a.c",
      "start": {
        "line": 80,
        "col": 13,
        "offset": 2424
      },
      "end": {
        "line": 80,
        "col": 49,
        "offset": 2460
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_68a.c",
      "start": {
        "line": 166,
        "col": 13,
        "offset": 5167
      },
      "end": {
        "line": 166,
        "col": 49,
        "offset": 5203
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_01.c",
      "start": {
        "line": 74,
        "col": 13,
        "offset": 2028
      },
      "end": {
        "line": 74,
        "col": 49,
        "offset": 2064
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_01.c",
      "start": {
        "line": 177,
        "col": 13,
        "offset": 4923
      },
      "end": {
        "line": 177,
        "col": 49,
        "offset": 4959
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_02.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2155
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2191
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_02.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 4988
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5024
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_02.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8071
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8107
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_03.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2164
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2200
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_03.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5009
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5045
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_03.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8098
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8134
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_04.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2475
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2511
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_04.c",
      "start": {
        "line": 175,
        "col": 17,
        "offset": 5373
      },
      "end": {
        "line": 175,
        "col": 53,
        "offset": 5409
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_04.c",
      "start": {
        "line": 274,
        "col": 17,
        "offset": 8489
      },
      "end": {
        "line": 274,
        "col": 53,
        "offset": 8525
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_05.c",
      "start": {
        "line": 82,
        "col": 17,
        "offset": 2474
      },
      "end": {
        "line": 82,
        "col": 53,
        "offset": 2510
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_05.c",
      "start": {
        "line": 175,
        "col": 17,
        "offset": 5344
      },
      "end": {
        "line": 175,
        "col": 53,
        "offset": 5380
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_05.c",
      "start": {
        "line": 274,
        "col": 17,
        "offset": 8446
      },
      "end": {
        "line": 274,
        "col": 53,
        "offset": 8482
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_06.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2406
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2442
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_06.c",
      "start": {
        "line": 174,
        "col": 17,
        "offset": 5315
      },
      "end": {
        "line": 174,
        "col": 53,
        "offset": 5351
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_06.c",
      "start": {
        "line": 273,
        "col": 17,
        "offset": 8436
      },
      "end": {
        "line": 273,
        "col": 53,
        "offset": 8472
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_07.c",
      "start": {
        "line": 81,
        "col": 17,
        "offset": 2414
      },
      "end": {
        "line": 81,
        "col": 53,
        "offset": 2450
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_07.c",
      "start": {
        "line": 174,
        "col": 17,
        "offset": 5295
      },
      "end": {
        "line": 174,
        "col": 53,
        "offset": 5331
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_07.c",
      "start": {
        "line": 273,
        "col": 17,
        "offset": 8402
      },
      "end": {
        "line": 273,
        "col": 53,
        "offset": 8438
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_08.c",
      "start": {
        "line": 89,
        "col": 17,
        "offset": 2488
      },
      "end": {
        "line": 89,
        "col": 53,
        "offset": 2524
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_08.c",
      "start": {
        "line": 182,
        "col": 17,
        "offset": 5394
      },
      "end": {
        "line": 182,
        "col": 53,
        "offset": 5430
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_08.c",
      "start": {
        "line": 281,
        "col": 17,
        "offset": 8514
      },
      "end": {
        "line": 281,
        "col": 53,
        "offset": 8550
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_09.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2204
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2240
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_09.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5102
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5138
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_09.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8218
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8254
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_10.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2183
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2219
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_10.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5053
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5089
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_10.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8155
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8191
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_11.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2210
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2246
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_11.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5116
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5152
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_11.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8236
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8272
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_12.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2195
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2231
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_12.c",
      "start": {
        "line": 190,
        "col": 17,
        "offset": 5673
      },
      "end": {
        "line": 190,
        "col": 53,
        "offset": 5709
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_12.c",
      "start": {
        "line": 262,
        "col": 17,
        "offset": 8084
      },
      "end": {
        "line": 262,
        "col": 53,
        "offset": 8120
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_13.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2212
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2248
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_13.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5121
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5157
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_13.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8242
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8278
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_14.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2191
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2227
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_14.c",
      "start": {
        "line": 169,
        "col": 17,
        "offset": 5072
      },
      "end": {
        "line": 169,
        "col": 53,
        "offset": 5108
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_14.c",
      "start": {
        "line": 268,
        "col": 17,
        "offset": 8179
      },
      "end": {
        "line": 268,
        "col": 53,
        "offset": 8215
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_15.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2092
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2128
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_15.c",
      "start": {
        "line": 182,
        "col": 13,
        "offset": 5020
      },
      "end": {
        "line": 182,
        "col": 49,
        "offset": 5056
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_15.c",
      "start": {
        "line": 288,
        "col": 13,
        "offset": 8073
      },
      "end": {
        "line": 288,
        "col": 49,
        "offset": 8109
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_16.c",
      "start": {
        "line": 76,
        "col": 17,
        "offset": 2151
      },
      "end": {
        "line": 76,
        "col": 53,
        "offset": 2187
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_16.c",
      "start": {
        "line": 171,
        "col": 17,
        "offset": 5042
      },
      "end": {
        "line": 171,
        "col": 53,
        "offset": 5078
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_17.c",
      "start": {
        "line": 77,
        "col": 17,
        "offset": 2180
      },
      "end": {
        "line": 77,
        "col": 53,
        "offset": 2216
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_17.c",
      "start": {
        "line": 171,
        "col": 17,
        "offset": 5051
      },
      "end": {
        "line": 171,
        "col": 53,
        "offset": 5087
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_18.c",
      "start": {
        "line": 76,
        "col": 13,
        "offset": 2076
      },
      "end": {
        "line": 76,
        "col": 49,
        "offset": 2112
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_18.c",
      "start": {
        "line": 167,
        "col": 13,
        "offset": 4654
      },
      "end": {
        "line": 167,
        "col": 49,
        "offset": 4690
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_21.c",
      "start": {
        "line": 90,
        "col": 13,
        "offset": 2495
      },
      "end": {
        "line": 90,
        "col": 49,
        "offset": 2531
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_21.c",
      "start": {
        "line": 201,
        "col": 13,
        "offset": 5653
      },
      "end": {
        "line": 201,
        "col": 49,
        "offset": 5689
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_21.c",
      "start": {
        "line": 298,
        "col": 13,
        "offset": 8448
      },
      "end": {
        "line": 298,
        "col": 49,
        "offset": 8484
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_22a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2373
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2409
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_22a.c",
      "start": {
        "line": 169,
        "col": 13,
        "offset": 5309
      },
      "end": {
        "line": 169,
        "col": 49,
        "offset": 5345
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_22a.c",
      "start": {
        "line": 250,
        "col": 13,
        "offset": 7888
      },
      "end": {
        "line": 250,
        "col": 49,
        "offset": 7924
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_31.c",
      "start": {
        "line": 74,
        "col": 13,
        "offset": 2075
      },
      "end": {
        "line": 74,
        "col": 49,
        "offset": 2111
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_31.c",
      "start": {
        "line": 185,
        "col": 13,
        "offset": 5170
      },
      "end": {
        "line": 185,
        "col": 49,
        "offset": 5206
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_32.c",
      "start": {
        "line": 78,
        "col": 17,
        "offset": 2273
      },
      "end": {
        "line": 78,
        "col": 53,
        "offset": 2309
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_32.c",
      "start": {
        "line": 199,
        "col": 17,
        "offset": 5826
      },
      "end": {
        "line": 199,
        "col": 53,
        "offset": 5862
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_34.c",
      "start": {
        "line": 81,
        "col": 13,
        "offset": 2329
      },
      "end": {
        "line": 81,
        "col": 49,
        "offset": 2365
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_34.c",
      "start": {
        "line": 194,
        "col": 13,
        "offset": 5604
      },
      "end": {
        "line": 194,
        "col": 49,
        "offset": 5640
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_41.c",
      "start": {
        "line": 84,
        "col": 13,
        "offset": 2311
      },
      "end": {
        "line": 84,
        "col": 49,
        "offset": 2347
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_41.c",
      "start": {
        "line": 202,
        "col": 13,
        "offset": 5455
      },
      "end": {
        "line": 202,
        "col": 49,
        "offset": 5491
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_42.c",
      "start": {
        "line": 71,
        "col": 13,
        "offset": 2007
      },
      "end": {
        "line": 71,
        "col": 49,
        "offset": 2043
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_42.c",
      "start": {
        "line": 186,
        "col": 13,
        "offset": 5130
      },
      "end": {
        "line": 186,
        "col": 49,
        "offset": 5166
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_44.c",
      "start": {
        "line": 86,
        "col": 13,
        "offset": 2427
      },
      "end": {
        "line": 86,
        "col": 49,
        "offset": 2463
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_44.c",
      "start": {
        "line": 207,
        "col": 13,
        "offset": 5691
      },
      "end": {
        "line": 207,
        "col": 49,
        "offset": 5727
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_45.c",
      "start": {
        "line": 89,
        "col": 13,
        "offset": 2626
      },
      "end": {
        "line": 89,
        "col": 49,
        "offset": 2662
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_45.c",
      "start": {
        "line": 211,
        "col": 13,
        "offset": 6066
      },
      "end": {
        "line": 211,
        "col": 49,
        "offset": 6102
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_51a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2227
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2263
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_51a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5120
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5156
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_52a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2244
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2280
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_52a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5137
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5173
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_53a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2271
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2307
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_53a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5164
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5200
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_54a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2272
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2308
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_54a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5165
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5201
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_61b.c",
      "start": {
        "line": 71,
        "col": 13,
        "offset": 2058
      },
      "end": {
        "line": 71,
        "col": 49,
        "offset": 2094
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_61b.c",
      "start": {
        "line": 158,
        "col": 13,
        "offset": 4675
      },
      "end": {
        "line": 158,
        "col": 49,
        "offset": 4711
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_63a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2228
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2264
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_63a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5127
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5163
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_64a.c",
      "start": {
        "line": 77,
        "col": 13,
        "offset": 2238
      },
      "end": {
        "line": 77,
        "col": 49,
        "offset": 2274
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_64a.c",
      "start": {
        "line": 174,
        "col": 13,
        "offset": 5153
      },
      "end": {
        "line": 174,
        "col": 49,
        "offset": 5189
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_65a.c",
      "start": {
        "line": 79,
        "col": 13,
        "offset": 2398
      },
      "end": {
        "line": 79,
        "col": 49,
        "offset": 2434
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_65a.c",
      "start": {
        "line": 179,
        "col": 13,
        "offset": 5407
      },
      "end": {
        "line": 179,
        "col": 49,
        "offset": 5443
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_66a.c",
      "start": {
        "line": 78,
        "col": 13,
        "offset": 2254
      },
      "end": {
        "line": 78,
        "col": 49,
        "offset": 2290
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_66a.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5298
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5334
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_67a.c",
      "start": {
        "line": 83,
        "col": 13,
        "offset": 2543
      },
      "end": {
        "line": 83,
        "col": 49,
        "offset": 2579
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_67a.c",
      "start": {
        "line": 184,
        "col": 13,
        "offset": 5798
      },
      "end": {
        "line": 184,
        "col": 49,
        "offset": 5834
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_68a.c",
      "start": {
        "line": 81,
        "col": 13,
        "offset": 2436
      },
      "end": {
        "line": 81,
        "col": 49,
        "offset": 2472
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    },
    {
      "check_id": "tools.semgrep-rules.c.lang.security.insecure-use-memset",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_68a.c",
      "start": {
        "line": 180,
        "col": 13,
        "offset": 5489
      },
      "end": {
        "line": 180,
        "col": 49,
        "offset": 5525
      },
      "extra": {
        "message": "When handling sensitive information in a buffer, it's important to ensure  that the data is securely erased before the buffer is deleted or reused.  While `memset()` is commonly used for this purpose, it can leave sensitive  information behind due to compiler optimizations or other factors.  To avoid this potential vulnerability, it's recommended to use the  `memset_s()` function instead. `memset_s()` is a standardized function  that securely overwrites the memory with a specified value, making it more  difficult for an attacker to recover any sensitive data that was stored in  the buffer. By using `memset_s()` instead of `memset()`, you can help to  ensure that your application is more secure and less vulnerable to exploits  that rely on residual data in memory.",
        "fix": "memset_s(&service, 0, sizeof(service)",
        "metadata": {
          "cwe": [
            "CWE-14: Compiler Removal of Code to Clear Buffers"
          ],
          "owasp": [
            "A04:2021 - Insecure Design"
          ],
          "references": [
            "https://cwe.mitre.org/data/definitions/14.html",
            "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
          ],
          "category": "security",
          "technology": [
            "c"
          ],
          "confidence": "LOW",
          "subcategory": [
            "audit"
          ],
          "likelihood": "LOW",
          "impact": "MEDIUM"
        },
        "severity": "WARNING",
        "fingerprint": "requires login",
        "lines": "requires login",
        "validation_state": "NO_VALIDATOR",
        "engine_kind": "OSS"
      }
    }
  ],
  "errors": [
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_01.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_01.c",
            "start": {
              "line": 60,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 60,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_01.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_01.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_01.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_01.c",
          "start": {
            "line": 60,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 60,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c",
            "start": {
              "line": 54,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 54,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c",
          "start": {
            "line": 54,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 54,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c",
            "start": {
              "line": 54,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 54,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c",
          "start": {
            "line": 54,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 54,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_04.c",
            "start": {
              "line": 36,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 36,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_04.c",
            "start": {
              "line": 60,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 60,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_04.c",
            "start": {
              "line": 90,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 90,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_04.c:36:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_04.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_04.c",
          "start": {
            "line": 36,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 36,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_04.c",
          "start": {
            "line": 60,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 60,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_04.c",
          "start": {
            "line": 90,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 90,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_05.c",
            "start": {
              "line": 36,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 36,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_05.c",
            "start": {
              "line": 60,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 60,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_05.c",
            "start": {
              "line": 90,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 90,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_05.c:36:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_05.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_05.c",
          "start": {
            "line": 36,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 36,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_05.c",
          "start": {
            "line": 60,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 60,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_05.c",
          "start": {
            "line": 90,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 90,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_06.c",
            "start": {
              "line": 35,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_06.c",
            "start": {
              "line": 59,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_06.c",
            "start": {
              "line": 89,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 89,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_06.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_06.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_06.c",
          "start": {
            "line": 35,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_06.c",
          "start": {
            "line": 59,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_06.c",
          "start": {
            "line": 89,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 89,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_07.c",
            "start": {
              "line": 35,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_07.c",
            "start": {
              "line": 59,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_07.c",
            "start": {
              "line": 89,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 89,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_07.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_07.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_07.c",
          "start": {
            "line": 35,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_07.c",
          "start": {
            "line": 59,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_07.c",
          "start": {
            "line": 89,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 89,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_08.c",
            "start": {
              "line": 43,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 43,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_08.c",
            "start": {
              "line": 67,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 67,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_08.c",
            "start": {
              "line": 97,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 97,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_08.c:43:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_08.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_08.c",
          "start": {
            "line": 43,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 43,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_08.c",
          "start": {
            "line": 67,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 67,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_08.c",
          "start": {
            "line": 97,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 97,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_09.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_09.c",
            "start": {
              "line": 54,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 54,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_09.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_09.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_09.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_09.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_09.c",
          "start": {
            "line": 54,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 54,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_09.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_10.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_10.c",
            "start": {
              "line": 54,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 54,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_10.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_10.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_10.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_10.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_10.c",
          "start": {
            "line": 54,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 54,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_10.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_11.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_11.c",
            "start": {
              "line": 54,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 54,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_11.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_11.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_11.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_11.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_11.c",
          "start": {
            "line": 54,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 54,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_11.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c",
            "start": {
              "line": 74,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 74,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c",
            "start": {
              "line": 79,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 79,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c",
          "start": {
            "line": 74,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 74,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c",
          "start": {
            "line": 79,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 79,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_13.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_13.c",
            "start": {
              "line": 54,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 54,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_13.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_13.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_13.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_13.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_13.c",
          "start": {
            "line": 54,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 54,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_13.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_14.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_14.c",
            "start": {
              "line": 54,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 54,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_14.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_14.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_14.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_14.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_14.c",
          "start": {
            "line": 54,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 54,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_14.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c",
            "start": {
              "line": 31,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c",
            "start": {
              "line": 67,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 67,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c",
            "start": {
              "line": 104,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 104,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c",
          "start": {
            "line": 31,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c",
          "start": {
            "line": 67,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 67,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c",
          "start": {
            "line": 104,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 104,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_16.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_16.c",
            "start": {
              "line": 56,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_16.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_16.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_16.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_16.c",
          "start": {
            "line": 56,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_17.c",
            "start": {
              "line": 31,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_17.c",
            "start": {
              "line": 56,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_17.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_17.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_17.c",
          "start": {
            "line": 31,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_17.c",
          "start": {
            "line": 56,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_18.c",
            "start": {
              "line": 30,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_18.c",
            "start": {
              "line": 52,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 52,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_18.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_18.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_18.c",
          "start": {
            "line": 30,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_18.c",
          "start": {
            "line": 52,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 52,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_21.c",
            "start": {
              "line": 43,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 43,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_21.c",
            "start": {
              "line": 85,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 85,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_21.c",
            "start": {
              "line": 113,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 113,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_21.c:43:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_21.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_21.c",
          "start": {
            "line": 43,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 43,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_21.c",
          "start": {
            "line": 85,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 85,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_21.c",
          "start": {
            "line": 113,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 113,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22a.c",
            "start": {
              "line": 55,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22a.c",
            "start": {
              "line": 68,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22a.c",
          "start": {
            "line": 55,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22a.c",
          "start": {
            "line": 68,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_31.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_31.c",
            "start": {
              "line": 68,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_31.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_31.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_31.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_31.c",
          "start": {
            "line": 68,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_32.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_32.c",
            "start": {
              "line": 82,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 82,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_32.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_32.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_32.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_32.c",
          "start": {
            "line": 82,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 82,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_34.c",
            "start": {
              "line": 35,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_34.c",
            "start": {
              "line": 77,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 77,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_34.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_34.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_34.c",
          "start": {
            "line": 35,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_34.c",
          "start": {
            "line": 77,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 77,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_41.c",
            "start": {
              "line": 37,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 37,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_41.c",
            "start": {
              "line": 84,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_41.c:37:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_41.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_41.c",
          "start": {
            "line": 37,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 37,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_41.c",
          "start": {
            "line": 84,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_42.c",
            "start": {
              "line": 26,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 26,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_42.c",
            "start": {
              "line": 70,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 70,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_42.c:26:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_42.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_42.c",
          "start": {
            "line": 26,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 26,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_42.c",
          "start": {
            "line": 70,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 70,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_44.c",
            "start": {
              "line": 39,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 39,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_44.c",
            "start": {
              "line": 89,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 89,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_44.c:39:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_44.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_44.c",
          "start": {
            "line": 39,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 39,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_44.c",
          "start": {
            "line": 89,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 89,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_45.c",
            "start": {
              "line": 42,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 42,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_45.c",
            "start": {
              "line": 93,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 93,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_45.c:42:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_45.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_45.c",
          "start": {
            "line": 42,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 42,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_45.c",
          "start": {
            "line": 93,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 93,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_51a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_51a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_51a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_51a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_51a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_51a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_61b.c",
            "start": {
              "line": 26,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 26,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_61b.c",
            "start": {
              "line": 46,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 46,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_61b.c:26:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_61b.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_61b.c",
          "start": {
            "line": 26,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 26,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_61b.c",
          "start": {
            "line": 46,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 46,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_63a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_63a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_63a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_63a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_63a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_63a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_64a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_64a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_64a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_64a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_64a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_64a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_65a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_65a.c",
            "start": {
              "line": 64,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 64,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_65a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_65a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_65a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_65a.c",
          "start": {
            "line": 64,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 64,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_66a.c",
            "start": {
              "line": 32,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_66a.c",
            "start": {
              "line": 65,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 65,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_66a.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_66a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_66a.c",
          "start": {
            "line": 32,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_66a.c",
          "start": {
            "line": 65,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 65,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_67a.c",
            "start": {
              "line": 37,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 37,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_67a.c",
            "start": {
              "line": 69,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 69,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_67a.c:37:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_67a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_67a.c",
          "start": {
            "line": 37,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 37,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_67a.c",
          "start": {
            "line": 69,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 69,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_68a.c",
            "start": {
              "line": 35,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_68a.c",
            "start": {
              "line": 65,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 65,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_68a.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_68a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_68a.c",
          "start": {
            "line": 35,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_68a.c",
          "start": {
            "line": 65,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 65,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_01.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_01.c",
            "start": {
              "line": 62,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 62,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_01.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_01.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_01.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_01.c",
          "start": {
            "line": 62,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 62,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c",
            "start": {
              "line": 88,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 88,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c",
          "start": {
            "line": 88,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 88,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c",
            "start": {
              "line": 88,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 88,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c",
          "start": {
            "line": 88,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 88,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_04.c",
            "start": {
              "line": 36,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 36,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_04.c",
            "start": {
              "line": 61,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_04.c",
            "start": {
              "line": 94,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 94,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_04.c:36:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_04.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_04.c",
          "start": {
            "line": 36,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 36,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_04.c",
          "start": {
            "line": 61,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_04.c",
          "start": {
            "line": 94,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 94,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c",
            "start": {
              "line": 36,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 36,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c",
            "start": {
              "line": 61,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c",
            "start": {
              "line": 94,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 94,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c:36:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c",
          "start": {
            "line": 36,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 36,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c",
          "start": {
            "line": 61,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c",
          "start": {
            "line": 94,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 94,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c",
            "start": {
              "line": 35,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c",
            "start": {
              "line": 60,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 60,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c",
            "start": {
              "line": 93,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 93,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c",
          "start": {
            "line": 35,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c",
          "start": {
            "line": 60,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 60,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c",
          "start": {
            "line": 93,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 93,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_07.c",
            "start": {
              "line": 35,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_07.c",
            "start": {
              "line": 60,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 60,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_07.c",
            "start": {
              "line": 93,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 93,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_07.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_07.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_07.c",
          "start": {
            "line": 35,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_07.c",
          "start": {
            "line": 60,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 60,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_07.c",
          "start": {
            "line": 93,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 93,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c",
            "start": {
              "line": 43,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 43,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c",
            "start": {
              "line": 68,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c",
            "start": {
              "line": 101,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 101,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c:43:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c",
          "start": {
            "line": 43,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 43,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c",
          "start": {
            "line": 68,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c",
          "start": {
            "line": 101,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 101,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_09.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_09.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_09.c",
            "start": {
              "line": 88,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 88,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_09.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_09.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_09.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_09.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_09.c",
          "start": {
            "line": 88,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 88,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_10.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_10.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_10.c",
            "start": {
              "line": 88,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 88,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_10.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_10.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_10.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_10.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_10.c",
          "start": {
            "line": 88,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 88,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_11.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_11.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_11.c",
            "start": {
              "line": 88,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 88,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_11.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_11.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_11.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_11.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_11.c",
          "start": {
            "line": 88,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 88,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_12.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_12.c",
            "start": {
              "line": 78,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 78,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_12.c",
            "start": {
              "line": 83,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 83,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_12.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_12.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_12.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_12.c",
          "start": {
            "line": 78,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 78,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_12.c",
          "start": {
            "line": 83,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 83,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c",
            "start": {
              "line": 88,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 88,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c",
          "start": {
            "line": 88,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 88,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c",
            "start": {
              "line": 88,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 88,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c",
          "start": {
            "line": 88,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 88,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_15.c",
            "start": {
              "line": 31,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_15.c",
            "start": {
              "line": 68,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_15.c",
            "start": {
              "line": 108,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 108,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_15.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_15.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_15.c",
          "start": {
            "line": 31,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_15.c",
          "start": {
            "line": 68,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_15.c",
          "start": {
            "line": 108,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 108,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_16.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_16.c",
            "start": {
              "line": 57,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 57,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_16.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_16.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_16.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_16.c",
          "start": {
            "line": 57,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 57,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c",
            "start": {
              "line": 31,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c",
            "start": {
              "line": 57,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 57,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c",
          "start": {
            "line": 31,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c",
          "start": {
            "line": 57,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 57,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_18.c",
            "start": {
              "line": 30,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_18.c",
            "start": {
              "line": 53,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 53,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_18.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_18.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_18.c",
          "start": {
            "line": 30,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_18.c",
          "start": {
            "line": 53,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 53,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c",
            "start": {
              "line": 44,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 44,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c",
            "start": {
              "line": 89,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 89,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c",
            "start": {
              "line": 120,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 120,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c:44:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c",
          "start": {
            "line": 44,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 44,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c",
          "start": {
            "line": 89,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 89,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c",
          "start": {
            "line": 120,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 120,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22a.c",
            "start": {
              "line": 55,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22a.c",
            "start": {
              "line": 68,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22a.c",
          "start": {
            "line": 55,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22a.c",
          "start": {
            "line": 68,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_31.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_31.c",
            "start": {
              "line": 70,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 70,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_31.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_31.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_31.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_31.c",
          "start": {
            "line": 70,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 70,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_32.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_32.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_32.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_32.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_32.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_32.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_34.c",
            "start": {
              "line": 35,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_34.c",
            "start": {
              "line": 79,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 79,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_34.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_34.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_34.c",
          "start": {
            "line": 35,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_34.c",
          "start": {
            "line": 79,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 79,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c",
            "start": {
              "line": 38,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 38,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c",
            "start": {
              "line": 89,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 89,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c:38:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c",
          "start": {
            "line": 38,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 38,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c",
          "start": {
            "line": 89,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 89,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_42.c",
            "start": {
              "line": 26,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 26,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_42.c",
            "start": {
              "line": 72,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 72,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_42.c:26:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_42.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_42.c",
          "start": {
            "line": 26,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 26,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_42.c",
          "start": {
            "line": 72,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 72,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c",
            "start": {
              "line": 40,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 40,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c",
            "start": {
              "line": 94,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 94,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c:40:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c",
          "start": {
            "line": 40,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 40,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c",
          "start": {
            "line": 94,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 94,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_45.c",
            "start": {
              "line": 43,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 43,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_45.c",
            "start": {
              "line": 98,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 98,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_45.c:43:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_45.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_45.c",
          "start": {
            "line": 43,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 43,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_45.c",
          "start": {
            "line": 98,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 98,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_51a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_51a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_51a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_51a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_51a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_51a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_52a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_52a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_52a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_52a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_52a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_52a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_61b.c",
            "start": {
              "line": 26,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 26,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_61b.c",
            "start": {
              "line": 46,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 46,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_61b.c:26:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_61b.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_61b.c",
          "start": {
            "line": 26,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 26,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_61b.c",
          "start": {
            "line": 46,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 46,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_63a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_63a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_63a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_63a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_63a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_63a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_64a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_64a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_64a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_64a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_64a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_64a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_65a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_65a.c",
            "start": {
              "line": 64,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 64,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_65a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_65a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_65a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_65a.c",
          "start": {
            "line": 64,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 64,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_66a.c",
            "start": {
              "line": 32,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_66a.c",
            "start": {
              "line": 65,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 65,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_66a.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_66a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_66a.c",
          "start": {
            "line": 32,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_66a.c",
          "start": {
            "line": 65,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 65,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_67a.c",
            "start": {
              "line": 37,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 37,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_67a.c",
            "start": {
              "line": 69,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 69,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_67a.c:37:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_67a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_67a.c",
          "start": {
            "line": 37,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 37,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_67a.c",
          "start": {
            "line": 69,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 69,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_68a.c",
            "start": {
              "line": 35,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_68a.c",
            "start": {
              "line": 65,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 65,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_68a.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_68a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_68a.c",
          "start": {
            "line": 35,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_68a.c",
          "start": {
            "line": 65,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 65,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_01.c",
            "start": {
              "line": 30,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_01.c",
            "start": {
              "line": 62,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 62,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_01.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_01.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_01.c",
          "start": {
            "line": 30,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_01.c",
          "start": {
            "line": 62,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 62,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_02.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_02.c",
            "start": {
              "line": 56,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_02.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_02.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_02.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_02.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_02.c",
          "start": {
            "line": 56,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_02.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c",
            "start": {
              "line": 56,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c",
          "start": {
            "line": 56,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c",
            "start": {
              "line": 38,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 38,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c",
            "start": {
              "line": 62,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 62,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c",
            "start": {
              "line": 92,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 92,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c:38:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c",
          "start": {
            "line": 38,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 38,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c",
          "start": {
            "line": 62,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 62,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c",
          "start": {
            "line": 92,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 92,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_05.c",
            "start": {
              "line": 38,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 38,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_05.c",
            "start": {
              "line": 62,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 62,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_05.c",
            "start": {
              "line": 92,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 92,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_05.c:38:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_05.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_05.c",
          "start": {
            "line": 38,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 38,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_05.c",
          "start": {
            "line": 62,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 62,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_05.c",
          "start": {
            "line": 92,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 92,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c",
            "start": {
              "line": 37,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 37,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c",
            "start": {
              "line": 61,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c",
            "start": {
              "line": 91,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 91,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c:37:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c",
          "start": {
            "line": 37,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 37,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c",
          "start": {
            "line": 61,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c",
          "start": {
            "line": 91,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 91,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_07.c",
            "start": {
              "line": 37,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 37,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_07.c",
            "start": {
              "line": 61,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_07.c",
            "start": {
              "line": 91,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 91,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_07.c:37:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_07.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_07.c",
          "start": {
            "line": 37,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 37,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_07.c",
          "start": {
            "line": 61,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_07.c",
          "start": {
            "line": 91,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 91,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_08.c",
            "start": {
              "line": 45,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 45,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_08.c",
            "start": {
              "line": 69,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 69,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_08.c",
            "start": {
              "line": 99,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 99,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_08.c:45:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_08.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_08.c",
          "start": {
            "line": 45,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 45,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_08.c",
          "start": {
            "line": 69,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 69,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_08.c",
          "start": {
            "line": 99,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 99,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_09.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_09.c",
            "start": {
              "line": 56,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_09.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_09.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_09.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_09.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_09.c",
          "start": {
            "line": 56,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_09.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c",
            "start": {
              "line": 56,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c",
          "start": {
            "line": 56,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_11.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_11.c",
            "start": {
              "line": 56,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_11.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_11.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_11.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_11.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_11.c",
          "start": {
            "line": 56,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_11.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c",
            "start": {
              "line": 76,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 76,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c",
            "start": {
              "line": 81,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 81,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c",
          "start": {
            "line": 76,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 76,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c",
          "start": {
            "line": 81,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 81,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_13.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_13.c",
            "start": {
              "line": 56,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_13.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_13.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_13.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_13.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_13.c",
          "start": {
            "line": 56,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_13.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c",
            "start": {
              "line": 56,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c",
          "start": {
            "line": 56,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_15.c",
            "start": {
              "line": 33,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_15.c",
            "start": {
              "line": 69,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 69,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_15.c",
            "start": {
              "line": 106,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 106,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_15.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_15.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_15.c",
          "start": {
            "line": 33,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_15.c",
          "start": {
            "line": 69,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 69,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_15.c",
          "start": {
            "line": 106,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 106,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_16.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_16.c",
            "start": {
              "line": 58,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 58,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_16.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_16.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_16.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_16.c",
          "start": {
            "line": 58,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 58,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_17.c",
            "start": {
              "line": 33,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_17.c",
            "start": {
              "line": 58,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 58,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_17.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_17.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_17.c",
          "start": {
            "line": 33,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_17.c",
          "start": {
            "line": 58,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 58,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_18.c",
            "start": {
              "line": 32,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_18.c",
            "start": {
              "line": 54,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 54,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_18.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_18.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_18.c",
          "start": {
            "line": 32,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_18.c",
          "start": {
            "line": 54,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 54,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_21.c",
            "start": {
              "line": 45,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 45,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_21.c",
            "start": {
              "line": 87,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 87,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_21.c",
            "start": {
              "line": 115,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 115,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_21.c:45:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_21.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_21.c",
          "start": {
            "line": 45,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 45,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_21.c",
          "start": {
            "line": 87,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 87,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_21.c",
          "start": {
            "line": 115,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 115,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22a.c",
            "start": {
              "line": 34,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 34,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22a.c",
            "start": {
              "line": 56,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 56,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22a.c",
            "start": {
              "line": 69,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 69,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22a.c:34:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22a.c",
          "start": {
            "line": 34,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 34,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22a.c",
          "start": {
            "line": 56,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 56,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22a.c",
          "start": {
            "line": 69,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 69,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_31.c",
            "start": {
              "line": 30,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_31.c",
            "start": {
              "line": 70,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 70,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_31.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_31.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_31.c",
          "start": {
            "line": 30,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_31.c",
          "start": {
            "line": 70,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 70,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_32.c",
            "start": {
              "line": 34,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 34,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_32.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_32.c:34:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_32.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_32.c",
          "start": {
            "line": 34,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 34,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_32.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_34.c",
            "start": {
              "line": 37,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 37,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_34.c",
            "start": {
              "line": 79,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 79,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_34.c:37:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_34.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_34.c",
          "start": {
            "line": 37,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 37,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_34.c",
          "start": {
            "line": 79,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 79,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_41.c",
            "start": {
              "line": 39,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 39,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_41.c",
            "start": {
              "line": 86,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_41.c:39:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_41.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_41.c",
          "start": {
            "line": 39,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 39,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_41.c",
          "start": {
            "line": 86,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_42.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_42.c",
            "start": {
              "line": 72,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 72,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_42.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_42.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_42.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_42.c",
          "start": {
            "line": 72,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 72,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_44.c",
            "start": {
              "line": 41,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 41,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_44.c",
            "start": {
              "line": 91,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 91,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_44.c:41:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_44.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_44.c",
          "start": {
            "line": 41,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 41,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_44.c",
          "start": {
            "line": 91,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 91,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_45.c",
            "start": {
              "line": 44,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 44,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_45.c",
            "start": {
              "line": 95,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 95,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_45.c:44:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_45.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_45.c",
          "start": {
            "line": 44,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 44,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_45.c",
          "start": {
            "line": 95,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 95,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_51a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_51a.c",
            "start": {
              "line": 61,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_51a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_51a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_51a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_51a.c",
          "start": {
            "line": 61,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_52a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_52a.c",
            "start": {
              "line": 61,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_52a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_52a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_52a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_52a.c",
          "start": {
            "line": 61,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53a.c",
            "start": {
              "line": 61,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53a.c",
          "start": {
            "line": 61,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54a.c",
            "start": {
              "line": 61,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54a.c",
          "start": {
            "line": 61,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_61b.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_61b.c",
            "start": {
              "line": 48,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 48,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_61b.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_61b.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_61b.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_61b.c",
          "start": {
            "line": 48,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 48,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_63a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_63a.c",
            "start": {
              "line": 61,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_63a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_63a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_63a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_63a.c",
          "start": {
            "line": 61,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_64a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_64a.c",
            "start": {
              "line": 61,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_64a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_64a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_64a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_64a.c",
          "start": {
            "line": 61,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_65a.c",
            "start": {
              "line": 35,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_65a.c",
            "start": {
              "line": 66,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 66,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_65a.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_65a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_65a.c",
          "start": {
            "line": 35,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_65a.c",
          "start": {
            "line": 66,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 66,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_66a.c",
            "start": {
              "line": 34,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 34,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_66a.c",
            "start": {
              "line": 67,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 67,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_66a.c:34:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_66a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_66a.c",
          "start": {
            "line": 34,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 34,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_66a.c",
          "start": {
            "line": 67,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 67,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_67a.c",
            "start": {
              "line": 39,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 39,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_67a.c",
            "start": {
              "line": 71,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 71,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_67a.c:39:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_67a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_67a.c",
          "start": {
            "line": 39,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 39,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_67a.c",
          "start": {
            "line": 71,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 71,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_68a.c",
            "start": {
              "line": 37,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 37,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_68a.c",
            "start": {
              "line": 67,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 67,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_68a.c:37:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_68a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_68a.c",
          "start": {
            "line": 37,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 37,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_68a.c",
          "start": {
            "line": 67,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 67,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_01.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_01.c",
            "start": {
              "line": 62,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 62,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_01.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_01.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_01.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_01.c",
          "start": {
            "line": 62,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 62,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_02.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_02.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_02.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_02.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_02.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_02.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_02.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_02.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_04.c",
            "start": {
              "line": 36,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 36,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_04.c",
            "start": {
              "line": 61,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_04.c",
            "start": {
              "line": 92,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 92,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_04.c:36:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_04.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_04.c",
          "start": {
            "line": 36,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 36,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_04.c",
          "start": {
            "line": 61,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_04.c",
          "start": {
            "line": 92,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 92,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_05.c",
            "start": {
              "line": 36,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 36,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_05.c",
            "start": {
              "line": 61,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_05.c",
            "start": {
              "line": 92,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 92,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_05.c:36:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_05.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_05.c",
          "start": {
            "line": 36,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 36,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_05.c",
          "start": {
            "line": 61,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_05.c",
          "start": {
            "line": 92,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 92,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_06.c",
            "start": {
              "line": 35,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_06.c",
            "start": {
              "line": 60,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 60,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_06.c",
            "start": {
              "line": 91,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 91,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_06.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_06.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_06.c",
          "start": {
            "line": 35,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_06.c",
          "start": {
            "line": 60,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 60,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_06.c",
          "start": {
            "line": 91,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 91,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c",
            "start": {
              "line": 35,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c",
            "start": {
              "line": 60,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 60,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c",
            "start": {
              "line": 91,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 91,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c",
          "start": {
            "line": 35,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c",
          "start": {
            "line": 60,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 60,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c",
          "start": {
            "line": 91,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 91,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c",
            "start": {
              "line": 43,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 43,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c",
            "start": {
              "line": 68,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c",
            "start": {
              "line": 99,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 99,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c:43:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c",
          "start": {
            "line": 43,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 43,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c",
          "start": {
            "line": 68,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c",
          "start": {
            "line": 99,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 99,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_09.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_09.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_09.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_09.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_09.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_09.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_09.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_09.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_11.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_11.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_11.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_11.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_11.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_11.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_11.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_11.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_12.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_12.c",
            "start": {
              "line": 76,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 76,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_12.c",
            "start": {
              "line": 81,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 81,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_12.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_12.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_12.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_12.c",
          "start": {
            "line": 76,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 76,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_12.c",
          "start": {
            "line": 81,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 81,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_14.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_14.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_14.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_14.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_14.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_14.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_14.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_14.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c",
            "start": {
              "line": 31,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c",
            "start": {
              "line": 68,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c",
            "start": {
              "line": 106,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 106,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c",
          "start": {
            "line": 31,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c",
          "start": {
            "line": 68,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c",
          "start": {
            "line": 106,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 106,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c",
            "start": {
              "line": 57,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 57,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c",
          "start": {
            "line": 57,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 57,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c",
            "start": {
              "line": 31,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c",
            "start": {
              "line": 57,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 57,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c",
          "start": {
            "line": 31,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c",
          "start": {
            "line": 57,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 57,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_18.c",
            "start": {
              "line": 30,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_18.c",
            "start": {
              "line": 53,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 53,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_18.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_18.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_18.c",
          "start": {
            "line": 30,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_18.c",
          "start": {
            "line": 53,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 53,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_21.c",
            "start": {
              "line": 44,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 44,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_21.c",
            "start": {
              "line": 87,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 87,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_21.c",
            "start": {
              "line": 116,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 116,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_21.c:44:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_21.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_21.c",
          "start": {
            "line": 44,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 44,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_21.c",
          "start": {
            "line": 87,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 87,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_21.c",
          "start": {
            "line": 116,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 116,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22a.c",
            "start": {
              "line": 55,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22a.c",
            "start": {
              "line": 68,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22a.c",
          "start": {
            "line": 55,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22a.c",
          "start": {
            "line": 68,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_31.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_31.c",
            "start": {
              "line": 70,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 70,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_31.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_31.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_31.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_31.c",
          "start": {
            "line": 70,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 70,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_32.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_32.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_32.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_32.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_32.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_32.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_34.c",
            "start": {
              "line": 35,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_34.c",
            "start": {
              "line": 79,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 79,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_34.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_34.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_34.c",
          "start": {
            "line": 35,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_34.c",
          "start": {
            "line": 79,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 79,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_41.c",
            "start": {
              "line": 38,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 38,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_41.c",
            "start": {
              "line": 87,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 87,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_41.c:38:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_41.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_41.c",
          "start": {
            "line": 38,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 38,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_41.c",
          "start": {
            "line": 87,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 87,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c",
            "start": {
              "line": 26,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 26,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c",
            "start": {
              "line": 72,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 72,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c:26:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c",
          "start": {
            "line": 26,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 26,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c",
          "start": {
            "line": 72,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 72,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_44.c",
            "start": {
              "line": 40,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 40,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_44.c",
            "start": {
              "line": 92,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 92,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_44.c:40:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_44.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_44.c",
          "start": {
            "line": 40,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 40,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_44.c",
          "start": {
            "line": 92,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 92,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c",
            "start": {
              "line": 43,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 43,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c",
            "start": {
              "line": 96,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 96,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c:43:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c",
          "start": {
            "line": 43,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 43,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c",
          "start": {
            "line": 96,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 96,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_51a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_51a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_51a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_51a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_51a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_51a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_61b.c",
            "start": {
              "line": 26,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 26,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_61b.c",
            "start": {
              "line": 46,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 46,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_61b.c:26:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_61b.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_61b.c",
          "start": {
            "line": 26,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 26,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_61b.c",
          "start": {
            "line": 46,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 46,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_63a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_63a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_63a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_63a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_63a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_63a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_64a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_64a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_64a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_64a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_64a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_64a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_65a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_65a.c",
            "start": {
              "line": 64,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 64,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_65a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_65a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_65a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_65a.c",
          "start": {
            "line": 64,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 64,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_66a.c",
            "start": {
              "line": 32,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_66a.c",
            "start": {
              "line": 65,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 65,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_66a.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_66a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_66a.c",
          "start": {
            "line": 32,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_66a.c",
          "start": {
            "line": 65,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 65,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_67a.c",
            "start": {
              "line": 37,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 37,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_67a.c",
            "start": {
              "line": 69,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 69,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_67a.c:37:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_67a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_67a.c",
          "start": {
            "line": 37,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 37,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_67a.c",
          "start": {
            "line": 69,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 69,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_68a.c",
            "start": {
              "line": 35,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_68a.c",
            "start": {
              "line": 65,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 65,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_68a.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_68a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_68a.c",
          "start": {
            "line": 35,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_68a.c",
          "start": {
            "line": 65,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 65,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_01.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_01.c",
            "start": {
              "line": 62,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 62,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_01.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_01.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_01.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_01.c",
          "start": {
            "line": 62,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 62,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_02.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_02.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_02.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_02.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_02.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_02.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_02.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_02.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_04.c",
            "start": {
              "line": 36,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 36,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_04.c",
            "start": {
              "line": 61,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_04.c",
            "start": {
              "line": 92,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 92,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_04.c:36:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_04.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_04.c",
          "start": {
            "line": 36,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 36,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_04.c",
          "start": {
            "line": 61,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_04.c",
          "start": {
            "line": 92,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 92,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_05.c",
            "start": {
              "line": 36,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 36,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_05.c",
            "start": {
              "line": 61,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 61,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_05.c",
            "start": {
              "line": 92,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 92,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_05.c:36:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_05.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_05.c",
          "start": {
            "line": 36,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 36,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_05.c",
          "start": {
            "line": 61,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 61,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_05.c",
          "start": {
            "line": 92,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 92,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c",
            "start": {
              "line": 35,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c",
            "start": {
              "line": 60,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 60,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c",
            "start": {
              "line": 91,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 91,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c",
          "start": {
            "line": 35,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c",
          "start": {
            "line": 60,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 60,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c",
          "start": {
            "line": 91,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 91,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c",
            "start": {
              "line": 35,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c",
            "start": {
              "line": 60,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 60,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c",
            "start": {
              "line": 91,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 91,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c",
          "start": {
            "line": 35,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c",
          "start": {
            "line": 60,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 60,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c",
          "start": {
            "line": 91,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 91,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c",
            "start": {
              "line": 43,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 43,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c",
            "start": {
              "line": 68,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c",
            "start": {
              "line": 99,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 99,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c:43:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c",
          "start": {
            "line": 43,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 43,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c",
          "start": {
            "line": 68,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c",
          "start": {
            "line": 99,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 99,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c",
            "start": {
              "line": 76,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 76,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c",
            "start": {
              "line": 81,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 81,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c",
          "start": {
            "line": 76,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 76,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c",
          "start": {
            "line": 81,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 81,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_14.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_14.c",
            "start": {
              "line": 55,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_14.c",
            "start": {
              "line": 86,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 86,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_14.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_14.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_14.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_14.c",
          "start": {
            "line": 55,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_14.c",
          "start": {
            "line": 86,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 86,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c",
            "start": {
              "line": 31,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c",
            "start": {
              "line": 68,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c",
            "start": {
              "line": 106,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 106,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c",
          "start": {
            "line": 31,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c",
          "start": {
            "line": 68,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c",
          "start": {
            "line": 106,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 106,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_16.c",
            "start": {
              "line": 30,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_16.c",
            "start": {
              "line": 57,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 57,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_16.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_16.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_16.c",
          "start": {
            "line": 30,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_16.c",
          "start": {
            "line": 57,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 57,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_17.c",
            "start": {
              "line": 31,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_17.c",
            "start": {
              "line": 57,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 57,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_17.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_17.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_17.c",
          "start": {
            "line": 31,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_17.c",
          "start": {
            "line": 57,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 57,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_18.c",
            "start": {
              "line": 30,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 30,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_18.c",
            "start": {
              "line": 53,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 53,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_18.c:30:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_18.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_18.c",
          "start": {
            "line": 30,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 30,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_18.c",
          "start": {
            "line": 53,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 53,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c",
            "start": {
              "line": 44,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 44,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c",
            "start": {
              "line": 87,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 87,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c",
            "start": {
              "line": 116,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 116,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c:44:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c",
          "start": {
            "line": 44,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 44,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c",
          "start": {
            "line": 87,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 87,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c",
          "start": {
            "line": 116,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 116,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22a.c",
            "start": {
              "line": 55,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 55,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22a.c",
            "start": {
              "line": 68,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 68,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22a.c",
          "start": {
            "line": 55,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 55,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22a.c",
          "start": {
            "line": 68,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 68,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_31.c",
            "start": {
              "line": 28,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 28,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_31.c",
            "start": {
              "line": 70,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 70,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_31.c:28:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_31.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_31.c",
          "start": {
            "line": 28,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 28,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_31.c",
          "start": {
            "line": 70,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 70,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_32.c",
            "start": {
              "line": 32,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 27,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_32.c",
            "start": {
              "line": 84,
              "col": 24,
              "offset": 0
            },
            "end": {
              "line": 84,
              "col": 27,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_32.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_32.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_32.c",
          "start": {
            "line": 32,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 27,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_32.c",
          "start": {
            "line": 84,
            "col": 24,
            "offset": 0
          },
          "end": {
            "line": 84,
            "col": 27,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_34.c",
            "start": {
              "line": 35,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_34.c",
            "start": {
              "line": 79,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 79,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_34.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_34.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_34.c",
          "start": {
            "line": 35,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_34.c",
          "start": {
            "line": 79,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 79,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_41.c",
            "start": {
              "line": 38,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 38,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_41.c",
            "start": {
              "line": 87,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 87,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_41.c:38:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_41.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_41.c",
          "start": {
            "line": 38,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 38,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_41.c",
          "start": {
            "line": 87,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 87,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_42.c",
            "start": {
              "line": 26,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 26,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_42.c",
            "start": {
              "line": 72,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 72,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_42.c:26:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_42.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_42.c",
          "start": {
            "line": 26,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 26,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_42.c",
          "start": {
            "line": 72,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 72,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c",
            "start": {
              "line": 40,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 40,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c",
            "start": {
              "line": 92,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 92,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c:40:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c",
          "start": {
            "line": 40,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 40,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c",
          "start": {
            "line": 92,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 92,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_45.c",
            "start": {
              "line": 43,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 43,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_45.c",
            "start": {
              "line": 96,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 96,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_45.c:43:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_45.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_45.c",
          "start": {
            "line": 43,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 43,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_45.c",
          "start": {
            "line": 96,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 96,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_52a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_52a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_52a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_52a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_52a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_52a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_61b.c",
            "start": {
              "line": 26,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 26,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_61b.c",
            "start": {
              "line": 46,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 46,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_61b.c:26:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_61b.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_61b.c",
          "start": {
            "line": 26,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 26,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_61b.c",
          "start": {
            "line": 46,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 46,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_63a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_63a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_63a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_63a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_63a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_63a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c",
            "start": {
              "line": 31,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 31,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c",
            "start": {
              "line": 59,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 59,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c:31:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c",
          "start": {
            "line": 31,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 31,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c",
          "start": {
            "line": 59,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 59,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_65a.c",
            "start": {
              "line": 33,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 33,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_65a.c",
            "start": {
              "line": 64,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 64,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_65a.c:33:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_65a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_65a.c",
          "start": {
            "line": 33,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 33,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_65a.c",
          "start": {
            "line": 64,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 64,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_66a.c",
            "start": {
              "line": 32,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 32,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_66a.c",
            "start": {
              "line": 65,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 65,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_66a.c:32:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_66a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_66a.c",
          "start": {
            "line": 32,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 32,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_66a.c",
          "start": {
            "line": 65,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 65,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_67a.c",
            "start": {
              "line": 37,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 37,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_67a.c",
            "start": {
              "line": 69,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 69,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_67a.c:37:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_67a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_67a.c",
          "start": {
            "line": 37,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 37,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_67a.c",
          "start": {
            "line": 69,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 69,
            "col": 23,
            "offset": 3
          }
        }
      ]
    },
    {
      "code": 3,
      "level": "warn",
      "type": [
        "PartialParsing",
        [
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_68a.c",
            "start": {
              "line": 35,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 35,
              "col": 23,
              "offset": 3
            }
          },
          {
            "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_68a.c",
            "start": {
              "line": 65,
              "col": 20,
              "offset": 0
            },
            "end": {
              "line": 65,
              "col": 23,
              "offset": 3
            }
          }
        ]
      ],
      "message": "Syntax error at line data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_68a.c:35:\n `\"%\"` was unexpected",
      "path": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_68a.c",
      "spans": [
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_68a.c",
          "start": {
            "line": 35,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 35,
            "col": 23,
            "offset": 3
          }
        },
        {
          "file": "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_68a.c",
          "start": {
            "line": 65,
            "col": 20,
            "offset": 0
          },
          "end": {
            "line": 65,
            "col": 23,
            "offset": 3
          }
        }
      ]
    }
  ],
  "paths": {
    "scanned": [
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_max_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_rand_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_max_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_rand_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_connect_socket_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int_fgets_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fgets_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_max_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__int_rand_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_max_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_rand_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__short_rand_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_max_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_add_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_multiply_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_81.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_82.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_83.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_rand_square_84.h",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_max_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_rand_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_max_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_rand_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_connect_socket_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fgets_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_listen_socket_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_max_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_rand_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_max_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_rand_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_max_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_rand_postinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_max_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_rand_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_max_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_rand_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_connect_socket_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fgets_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_listen_socket_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_max_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_rand_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_max_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_rand_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_max_preinc_68b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_01.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_02.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_03.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_04.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_05.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_06.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_07.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_08.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_09.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_10.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_11.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_12.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_13.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_14.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_15.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_16.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_17.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_18.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_21.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_22a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_22b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_31.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_32.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_34.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_41.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_42.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_44.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_45.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_51a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_52a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_52b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_52c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_53a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_53b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_53c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_53d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_54a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_54b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_54c.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_54d.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_54e.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_61a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_61b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_63a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_63b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_64a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_64b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_65a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_66a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_66b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_67a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_68a.c",
      "data/juliet/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_rand_preinc_68b.c"
    ]
  },
  "time": {
    "rules": [],
    "rules_parse_time": 0.04705309867858887,
    "profiling_times": {
      "config_time": 0.3222658634185791,
      "core_time": 6.584970951080322,
      "ignores_time": 0.00016999244689941406,
      "total_time": 6.908203125
    },
    "parsing_time": {
      "total_time": 0.0,
      "per_file_time": {
        "mean": 0.0,
        "std_dev": 0.0
      },
      "very_slow_stats": {
        "time_ratio": 0.0,
        "count_ratio": 0.0
      },
      "very_slow_files": []
    },
    "scanning_time": {
      "total_time": 14.884630918502808,
      "per_file_time": {
        "mean": 0.002831931301085002,
        "std_dev": 0.000019456547384410387
      },
      "very_slow_stats": {
        "time_ratio": 0.0,
        "count_ratio": 0.0
      },
      "very_slow_files": []
    },
    "matching_time": {
      "total_time": 0.0,
      "per_file_and_rule_time": {
        "mean": 0.0,
        "std_dev": 0.0
      },
      "very_slow_stats": {
        "time_ratio": 0.0,
        "count_ratio": 0.0
      },
      "very_slow_rules_on_files": []
    },
    "tainting_time": {
      "total_time": 0.0,
      "per_def_and_rule_time": {
        "mean": 0.0,
        "std_dev": 0.0
      },
      "very_slow_stats": {
        "time_ratio": 0.0,
        "count_ratio": 0.0
      },
      "very_slow_rules_on_defs": []
    },
    "fixpoint_timeouts": [],
    "prefiltering": {
      "project_level_time": 0.0,
      "file_level_time": 0.0,
      "rules_with_project_prefilters_ratio": 0.0,
      "rules_with_file_prefilters_ratio": 1.0,
      "rules_selected_ratio": 0.03380263825469305,
      "rules_matched_ratio": 0.03380263825469305
    },
    "targets": [],
    "total_bytes": 0,
    "max_memory_bytes": 220745536
  },
  "engine_requested": "OSS",
  "skipped_rules": []
}
